<?xml version="1.0"?>
<doc>
    <assembly>
        <name>qyoto-qtopengl</name>
    </assembly>
    <members>
        <member name="T:QtOpenGL.QGLBuffer">
            <summary>
            The QGLBuffer class provides functions for creating and managing GL buffer objects.
            </summary>
            <remarks>
                <para>
                </para>
                <para>Buffer objects are created in the GL server so that the client application can avoid uploading vertices, indices, texture image data, etc every time they are needed.</para>
                <para>QGLBuffer objects can be copied around as a reference to the underlying GL buffer object:</para>
                <para> QGLBuffer buffer1(QGLBuffer::IndexBuffer);</para>
                <para> buffer1.create();</para>
                <para>
                </para>
                <para> QGLBuffer buffer2 = buffer1;</para>
                <para>QGLBuffer performs a shallow copy when objects are copied in this manner, but does not implement copy-on-write semantics. The original object will be affected whenever the copy is modified.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.#ctor">
            <summary>
                <para>Constructs a new buffer object of type QGLBuffer::VertexBuffer.</para>
                <para>Note: this constructor just creates the QGLBuffer instance. The actual buffer object in the GL server is not created until create() is called.</para>
                <para>See also create().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.#ctor(QtOpenGL.QGLBuffer)">
            <summary>
                <para>Constructs a shallow copy of other.</para>
                <para>Note: QGLBuffer does not implement copy-on-write semantics, so other will be affected whenever the copy is modified.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.#ctor(QtOpenGL.QGLBuffer.Type)">
            <summary>
                <para>Constructs a new buffer object of type.</para>
                <para>Note: this constructor just creates the QGLBuffer instance. The actual buffer object in the GL server is not created until create() is called.</para>
                <para>See also create().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLBuffer.Access">
            <summary>
                <para>This enum defines the access mode for QGLBuffer::map().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Access.ReadOnly">
            <summary>
                <para>The buffer will be mapped for reading only.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Access.ReadWrite">
            <summary>
                <para>The buffer will be mapped for reading and writing.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Access.WriteOnly">
            <summary>
                <para>The buffer will be mapped for writing only.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLBuffer.Type">
            <summary>
                <para>This enum defines the type of GL buffer object to create with QGLBuffer.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.IndexBuffer">
            <summary>
                <para>Index buffer object for use with glDrawElements().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.PixelPackBuffer">
            <summary>
                <para>Pixel pack buffer object for reading pixel data from the GL server (for example, with glReadPixels()). Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.PixelUnpackBuffer">
            <summary>
                <para>Pixel unpack buffer object for writing pixel data to the GL server (for example, with glTexImage2D()). Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.VertexBuffer">
            <summary>
                <para>Vertex buffer object for use when specifying vertex arrays.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLBuffer.UsagePattern">
            <summary>
                <para>This enum defines the usage pattern of a QGLBuffer object.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.DynamicCopy">
            <summary>
                <para>The data will be modified repeatedly and used many times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.DynamicDraw">
            <summary>
                <para>The data will be modified repeatedly and used many times for drawing operations.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.DynamicRead">
            <summary>
                <para>The data will be modified repeatedly and used many times for reading data back from the GL server. Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StaticCopy">
            <summary>
                <para>The data will be set once and used many times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StaticDraw">
            <summary>
                <para>The data will be set once and used many times for drawing operations.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StaticRead">
            <summary>
                <para>The data will be set once and used many times for reading data back from the GL server. Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StreamCopy">
            <summary>
                <para>The data will be set once and used a few times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StreamDraw">
            <summary>
                <para>The data will be set once and used a few times for drawing operations. Under OpenGL/ES 1.1 this is identical to StaticDraw.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StreamRead">
            <summary>
                <para>The data will be set once and used a few times for reading data back from the GL server. Not supported under OpenGL/ES.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.usagePattern">
            <summary>
                <para>Returns the usage pattern for this buffer object. The default value is StaticDraw.</para>
                <para>Sets the usage pattern for this buffer object to value. This function must be called before allocate() or write().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.BufferId">
            <summary>
                <para>Returns the GL identifier associated with this buffer; zero if the buffer has not been created.</para>
                <para>See also isCreated().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.IsCreated">
            <summary>
                <para>Returns true if this buffer has been created; false otherwise.</para>
                <para>See also create() and destroy().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.Size">
            <summary>
                <para>Returns the size of the data in this buffer, for reading operations. Returns -1 if fetching the buffer size is not supported, or the buffer has not been created.</para>
                <para>It is assumed that this buffer has been bound to the current context.</para>
                <para>See also isCreated() and bind().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.type">
            <summary>
                <para>Returns the type of buffer represented by this object.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Allocate(System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Allocates count bytes of space to the buffer. Any previous contents will be removed.</para>
                <para>It is assumed that create() has been called on this buffer and that it has been bound to the current context.</para>
                <para>See also create() and write().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Bind">
            <summary>
                <para>Binds the buffer associated with this object to the current GL context. Returns false if binding was not possible, usually because type() is not supported on this GL implementation.</para>
                <para>The buffer must be bound to the same QGLContext current when create() was called, or to another QGLContext that is sharing with it. Otherwise, false will be returned from this function.</para>
                <para>See also release() and create().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Create">
            <summary>
                <para>Creates the buffer object in the GL server. Returns true if the object was created; false otherwise.</para>
                <para>This function must be called with a current QGLContext. The buffer will be bound to and can only be used in that context (or any other context that is shared with it).</para>
                <para>This function will return false if the GL implementation does not support buffers, or there is no current QGLContext.</para>
                <para>See also isCreated(), allocate(), write(), and destroy().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Destroy">
            <summary>
                <para>Destroys this buffer object, including the storage being used in the GL server. All references to the buffer will become invalid.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Release">
            <summary>
                <para>Releases the buffer associated with this object from the current GL context.</para>
                <para>This function must be called with the same QGLContext current as when bind() was called on the buffer.</para>
                <para>See also bind().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Release(QtOpenGL.QGLBuffer.Type)">
            <summary>
                <para>Releases the buffer associated with type in the current QGLContext.</para>
                <para>This function is a direct call to glBindBuffer(type, 0) for use when the caller does not know which QGLBuffer has been bound to the context but wants to make sure that it is released.</para>
                <para> QGLBuffer::release(QGLBuffer::VertexBuffer);</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Unmap">
            <summary>
                <para>Unmaps the buffer after it was mapped into the application's memory space with a previous call to map(). Returns true if the unmap succeeded; false otherwise.</para>
                <para>It is assumed that this buffer has been bound to the current context, and that it was previously mapped with map().</para>
                <para>This function is only supported under OpenGL/ES if the GL_OES_mapbuffer extension is present.</para>
                <para>See also map().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Finalize">
            <summary>
                <para>Destroys this buffer object, including the storage being used in the GL server.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLColormap">
            <summary>
            The QGLColormap class is used for installing custom colormaps into a QGLWidget.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QGLColormap provides a platform independent way of specifying and installing indexed colormaps for a QGLWidget. QGLColormap is especially useful when using the OpenGL color-index mode.</para>
                <para>Under X11 you must use an X server that supports either a PseudoColor or DirectColor visual class. If your X server currently only provides a GrayScale, TrueColor, StaticColor or StaticGray visual, you will not be able to allocate colorcells for writing. If this is the case, try setting your X server to 8 bit mode. It should then provide you with at least a PseudoColor visual. Note that you may experience colormap flashing if your X server is running in 8 bit mode.</para>
                <para>The size() of the colormap is always set to 256 colors. Note that under Windows you can also install colormaps in child widgets.</para>
                <para>This class uses implicit sharing as a memory and speed optimization.</para>
                <para>Example of use:</para>
                <para> #include &lt;QApplication&gt;</para>
                <para> #include &lt;QGLColormap&gt;</para>
                <para>
                </para>
                <para> int main(int argc, char *argv[])</para>
                <para> {</para>
                <para>     QApplication app(argc, argv);</para>
                <para>
                </para>
                <para>     MySuperGLWidget widget;     // a QGLWidget in color-index mode</para>
                <para>     QGLColormap colormap;</para>
                <para>
                </para>
                <para>     // This will fill the colormap with colors ranging from</para>
                <para>     // black to white.</para>
                <para>     const int size = 256;</para>
                <para>     for (int i = 0; i &lt; size; ++i)</para>
                <para>         colormap.setEntry(i, qRgb(i, i, i));</para>
                <para>
                </para>
                <para>     widget.setColormap(colormap);</para>
                <para>     widget.show();</para>
                <para>     return app.exec();</para>
                <para> }</para>
                <para>
                </para>
                <para>See also QGLWidget::setColormap() and QGLWidget::colormap().</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLColormap.#ctor">
            <summary>
                <para>Construct a QGLColormap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.#ctor(QtOpenGL.QGLColormap)">
            <summary>
                <para>Construct a shallow copy of map.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLColormap.IsEmpty">
            <summary>
                <para>Returns true if the colormap is empty or it is not in use by a QGLWidget; otherwise returns false.</para>
                <para>A colormap with no color values set is considered to be empty. For historical reasons, a colormap that has color values set but which is not in use by a QGLWidget is also considered empty.</para>
                <para>Compare size() with zero to determine if the colormap is empty regardless of whether it is in use by a QGLWidget or not.</para>
                <para>See also size().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLColormap.Size">
            <summary>
                <para>Returns the number of colorcells in the colormap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.EntryColor(System.Int32)">
            <summary>
                <para>Returns the QRgb value in the colorcell with index idx.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.EntryRgb(System.Int32)">
            <summary>
                <para>Returns the QRgb value in the colorcell with index idx.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.Find(System.UInt32)">
            <summary>
                <para>Returns the index of the color color. If color is not in the map, -1 is returned.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.FindNearest(System.UInt32)">
            <summary>
                <para>Returns the index of the color that is the closest match to color color.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.SetEntries(System.Int32,System.UInt32@,System.Int32)">
            <summary>
                <para>Set an array of cells in this colormap. count is the number of colors that should be set, colors is the array of colors, and base is the starting index. The first element in colors is set at base in the colormap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.SetEntry(System.Int32,QtGui.QColor)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Set the cell with index idx in the colormap to color color.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.SetEntry(System.Int32,System.UInt32)">
            <summary>
                <para>Set cell at index idx in the colormap to color color.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.Finalize">
            <summary>
                <para>Dereferences the QGLColormap and deletes it if this was the last reference to it.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLContext">
            <summary>
            The QGLContext class encapsulates an OpenGL rendering context.
            </summary>
            <remarks>
                <para>
                </para>
                <para>An OpenGL rendering context is a complete set of OpenGL state variables. The rendering context's format is set in the constructor, but it can also be set later with setFormat(). The format options that are actually set are returned by format(); the options you asked for are returned by requestedFormat(). Note that after a QGLContext object has been constructed, the actual OpenGL context must be created by explicitly calling the create() function. The makeCurrent() function makes this context the current rendering context. You can make no context current using doneCurrent(). The reset() function will reset the context and make it invalid.</para>
                <para>You can examine properties of the context with, e.g. isValid(), isSharing(), initialized(), windowCreated() and overlayTransparentColor().</para>
                <para>If you're using double buffering you can swap the screen contents with the off-screen buffer using swapBuffers().</para>
                <para>Please note that QGLContext is not thread-safe.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLContext.#ctor(QtOpenGL.QGLFormat)">
            <summary>
                <para>Constructs an OpenGL context with the given format which specifies several display options for the context.</para>
                <para>If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</para>
                <para>Note that after a QGLContext object has been constructed, create() must be called explicitly to create the actual OpenGL context. The context will be invalid if it was not possible to obtain a GL context at all.</para>
                <para>See also format() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.#ctor(QtOpenGL.QGLFormat,QtGui.IQPaintDevice)">
            <summary>
                <para>Constructs an OpenGL context for the given paint device, which can be a widget or a pixmap. The format specifies several display options for the context.</para>
                <para>If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</para>
                <para>Note that after a QGLContext object has been constructed, create() must be called explicitly to create the actual OpenGL context. The context will be invalid if it was not possible to obtain a GL context at all.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLContext.BindOption">
            <summary>
                <para>A set of options to decide how to bind a texture using bindTexture().</para>
                <para>Used by x11 from pixmap to choose whether or not it can bind the pixmap upside down or not.</para>
                <para>Used by paint engines to indicate that the pixmap should be memory managed along side with the pixmap/image that it stems from, e.g. installing destruction hooks in them.</para>
                <para>This enum was introduced or modified in Qt 4.6.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.DefaultBindOption">
            <summary>
                <para>In Qt 4.5 and earlier, bindTexture() would mirror the image and automatically generate mipmaps. This option helps preserve this default behavior.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.InvertedYBindOption">
            <summary>
                <para>Specifies that the texture should be flipped over the X axis so that the texture coordinate 0,0 corresponds to the top left corner. Inverting the texture implies a deep copy prior to upload.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.LinearFilteringBindOption">
            <summary>
                <para>Specifies that the texture filtering should be set to GL_LINEAR. Default is GL_NEAREST. If mipmap is also enabled, filtering will be set to GL_LINEAR_MIPMAP_LINEAR.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.MipmapBindOption">
            <summary>
                <para>Specifies that bindTexture() should try to generate mipmaps. If the GL implementation supports the GL_SGIS_generate_mipmap extension, mipmaps will be automatically generated for the texture. Mipmap generation is only supported for the GL_TEXTURE_2D target.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.NoBindOption">
            <summary>
                <para>Don't do anything, pass the texture straight through.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.PremultipliedAlphaBindOption">
            <summary>
                <para>Specifies that the image should be uploaded with premultiplied alpha and does a conversion accordingly.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Device">
            <summary>
                <para>Returns the paint device set for this context.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Format">
            <summary>
                <para>Returns the frame buffer format that was obtained (this may be a subset of what was requested).</para>
                <para>Sets a format for this context. The context is reset.</para>
                <para>Call create() to create a new GL context that tries to match the new format.</para>
                <para> QGLContext *cx;</para>
                <para> //  ...</para>
                <para> QGLFormat f;</para>
                <para> f.setStereo(true);</para>
                <para> cx-&gt;setFormat(f);</para>
                <para> if (!cx-&gt;create())</para>
                <para>     exit(); // no OpenGL support, or cannot render on the specified paintdevice</para>
                <para> if (!cx-&gt;format().stereo())</para>
                <para>     exit(); // could not create stereo context</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Initialized">
            <summary>
                <para>Returns true if this context has been initialized, i.e. if QGLWidget::initializeGL() has been performed on it; otherwise returns false.</para>
                <para>If on is true the context has been initialized, i.e. QGLContext::setInitialized() has been called on it. If on is false the context has not been initialized.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.TextureCacheLimit">
            <summary>
                <para>Returns the current texture cache limit in kilobytes.</para>
                <para>This function sets the limit for the texture cache to size, expressed in kilobytes.</para>
                <para>By default, the cache limit is approximately 64 MB.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.WindowCreated">
            <summary>
                <para>Returns true if a window has been created for this context; otherwise returns false.</para>
                <para>If on is true the context has had a window created for it. If on is false no window has been created for the context.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.CurrentContext">
            <summary>
                <para>Returns the current context, i.e. the context to which any OpenGL commands will currently be directed. Returns 0 if no context is current.</para>
                <para>See also makeCurrent().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.DeviceIsPixmap">
            <summary>
                <para>Returns true if the paint device of this context is a pixmap; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.IsSharing">
            <summary>
                <para>Returns true if this context is sharing its GL context with another QGLContext, otherwise false is returned. Note that context sharing might not be supported between contexts with different formats.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.IsValid">
            <summary>
                <para>Returns true if a GL rendering context has been successfully created; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.OverlayTransparentColor">
            <summary>
                <para>If this context is a valid context in an overlay plane, returns the plane's transparent color. Otherwise returns an {QColor::isValid()}{invalid} color.</para>
                <para>The returned QColor object will generally work as expected only when passed as the argument to QGLWidget::qglColor() or QGLWidget::qglClearColor(). Under certain circumstances it can also be used to draw transparent graphics with a QPainter.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.RequestedFormat">
            <summary>
                <para>Returns the frame buffer format that was originally requested in the constructor or setFormat().</para>
                <para>See also format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.AreSharing(QtOpenGL.QGLContext,QtOpenGL.QGLContext)">
            <summary>
                <para>Returns true if context1 and context2 are sharing their GL resources such as textures, shader programs, etc; otherwise returns false.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QImage)">
            <summary>
                <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
                <para>This is an overloaded function.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QPixmap)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Generates and binds a 2D GL texture based on pixmap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QImage,System.Int32)">
            <summary>
                <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
                <para>This is an overloaded function.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QPixmap,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Generates and binds a 2D GL texture based on pixmap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QImage,System.Int32,System.Int32)">
            <summary>
                <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
                <para>This is an overloaded function.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QPixmap,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Generates and binds a 2D GL texture based on pixmap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QImage,System.Int32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
                <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
                <para>The target parameter specifies the texture target. The default target is GL_TEXTURE_2D.</para>
                <para>The format parameter sets the internal format for the texture. The default format is GL_RGBA.</para>
                <para>The binding options are a set of options used to decide how to bind the texture to the context.</para>
                <para>The texture that is generated is cached, so multiple calls to bindTexture() with the same QImage will return the same texture id.</para>
                <para>Note that we assume default values for the glPixelStore() and glPixelTransfer() parameters.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QPixmap,System.Int32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Generates and binds a 2D GL texture to the current context, based on pixmap.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Reads the compressed texture file fileName and generates a 2D GL texture from it.</para>
                <para>This function can load DirectDrawSurface (DDS) textures in the DXT1, DXT3 and DXT5 DDS formats if the GL_ARB_texture_compression and GL_EXT_texture_compression_s3tc extensions are supported.</para>
                <para>Since 4.6.1, textures in the ETC1 format can be loaded if the GL_OES_compressed_ETC1_RGB8_texture extension is supported and the ETC1 texture has been encapsulated in the PVR container format. Also, textures in the PVRTC2 and PVRTC4 formats can be loaded if the GL_IMG_texture_compression_pvrtc extension is supported.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.ChooseContext(QtOpenGL.QGLContext)">
            <summary>
                <para>This semi-internal function is called by create(). It creates a system-dependent OpenGL handle that matches the format() of shareContext as closely as possible, returning true if successful or false if a suitable handle could not be found.</para>
                <para>On Windows, it calls the virtual function choosePixelFormat(), which finds a matching pixel format identifier. On X11, it calls the virtual function chooseVisual() which finds an appropriate X visual. On other platforms it may work differently.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.Create(QtOpenGL.QGLContext)">
            <summary>
                <para>Creates the GL context. Returns true if it was successful in creating a valid GL rendering context on the paint device specified in the constructor; otherwise returns false (i.e. the context is invalid).</para>
                <para>After successful creation, format() returns the set of features of the created GL rendering context.</para>
                <para>If shareContext points to a valid QGLContext, this method will try to establish OpenGL display list and texture object sharing between this context and the shareContext. Note that this may fail if the two contexts have different formats. Use isSharing() to see if sharing is in effect.</para>
                <para>Warning: Implementation note: initialization of C++ class members usually takes place in the class constructor. QGLContext is an exception because it must be simple to customize. The virtual functions chooseContext() (and chooseVisual() for X11) can be reimplemented in a subclass to select a particular context. The problem is that virtual functions are not properly called during construction (even though this is correct C++) because C++ constructs class hierarchies from the bottom up. For this reason we need a create() function.</para>
                <para>See also chooseContext(), format(), and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DeleteTexture(System.UInt32)">
            <summary>
                <para>Removes the texture identified by id from the texture cache, and calls glDeleteTextures() to delete the texture from the context.</para>
                <para>See also bindTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DoneCurrent">
            <summary>
                <para>Makes no GL context the current context. Normally, you do not need to call this function; QGLContext calls it as necessary.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DrawTexture(QtCore.QRectF,System.UInt32)">
            <summary>
                <para>This function supports the following use cases:</para>
                <para>
                </para>
                <para>On OpenGL and OpenGL ES 1.x it draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>On OpenGL and OpenGL ES 2.x, if a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type QPaintEngine::OpenGL2, the function will draw the given texture, textureId, to the given target rectangle, target, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case, and that this is the only supported use case under OpenGL ES 2.x.</para>
                <para>
                </para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DrawTexture(QtCore.QPointF,System.UInt32)">
            <summary>
                <para>This function supports the following use cases:</para>
                <para>
                </para>
                <para>By default it draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>If a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type QPaintEngine::OpenGL2, the function will draw the given texture, textureId, at the given point, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case.</para>
                <para>
                </para>
                <para>Note: This function is not supported under any version of OpenGL ES.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DrawTexture(QtCore.QRectF,System.UInt32,System.Int32)">
            <summary>
                <para>This function supports the following use cases:</para>
                <para>
                </para>
                <para>On OpenGL and OpenGL ES 1.x it draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>On OpenGL and OpenGL ES 2.x, if a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type QPaintEngine::OpenGL2, the function will draw the given texture, textureId, to the given target rectangle, target, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case, and that this is the only supported use case under OpenGL ES 2.x.</para>
                <para>
                </para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DrawTexture(QtCore.QPointF,System.UInt32,System.Int32)">
            <summary>
                <para>This function supports the following use cases:</para>
                <para>
                </para>
                <para>By default it draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>If a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type QPaintEngine::OpenGL2, the function will draw the given texture, textureId, at the given point, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case.</para>
                <para>
                </para>
                <para>Note: This function is not supported under any version of OpenGL ES.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.GenerateFontDisplayLists(QtGui.QFont,System.Int32)">
            <summary>
                <para>Generates a set of 256 display lists for the 256 first characters in the font font. The first list will start at index listBase.</para>
                <para>See also QGLWidget::renderText().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.MakeCurrent">
            <summary>
                <para>Makes this context the current OpenGL rendering context. All GL functions you call operate on this context until another context is made current.</para>
                <para>In some very rare cases the underlying call may fail. If this occurs an error message is output to stderr.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.Reset">
            <summary>
                <para>Resets the context and makes it invalid.</para>
                <para>See also create() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.SwapBuffers">
            <summary>
                <para>Swaps the screen contents with an off-screen buffer. Only works if the context is in double buffer mode.</para>
                <para>See also QGLFormat::setDoubleBuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.Finalize">
            <summary>
                <para>Destroys the OpenGL context and frees its resources.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFormat">
            <summary>
            The QGLFormat class specifies the display format of an OpenGL rendering context.
            </summary>
            <remarks>
                <para>
                </para>
                <para>A display format has several characteristics:</para>
                <para>
                </para>
                <para>Double or single buffering.</para>
                <para>Depth buffer.</para>
                <para>RGBA or color index mode.</para>
                <para>Alpha channel.</para>
                <para>Accumulation buffer.</para>
                <para>Stencil buffer.</para>
                <para>Stereo buffers.</para>
                <para>Direct rendering.</para>
                <para>Presence of an overlay.</para>
                <para>Plane of an overlay.</para>
                <para>Multisample buffers.</para>
                <para>
                </para>
                <para>You can also specify preferred bit depths for the color buffer, depth buffer, alpha buffer, accumulation buffer and the stencil buffer with the functions: setRedBufferSize(), setGreenBufferSize(), setBlueBufferSize(), setDepthBufferSize(), setAlphaBufferSize(), setAccumBufferSize() and setStencilBufferSize().</para>
                <para>Note that even if you specify that you prefer a 32 bit depth buffer (e.g. with setDepthBufferSize(32)), the format that is chosen may not have a 32 bit depth buffer, even if there is a format available with a 32 bit depth buffer. The main reason for this is how the system dependant picking algorithms work on the different platforms, and some format options may have higher precedence than others.</para>
                <para>You create and tell a QGLFormat object what rendering options you want from an OpenGL rendering context.</para>
                <para>OpenGL drivers or accelerated hardware may or may not support advanced features such as alpha channel or stereographic viewing. If you request some features that the driver/hardware does not provide when you create a QGLWidget, you will get a rendering context with the nearest subset of features.</para>
                <para>There are different ways to define the display characteristics of a rendering context. One is to create a QGLFormat and make it the default for the entire application:</para>
                <para> QGLFormat fmt;</para>
                <para> fmt.setAlpha(true);</para>
                <para> fmt.setStereo(true);</para>
                <para> QGLFormat::setDefaultFormat(fmt);</para>
                <para>Or you can specify the desired format when creating an object of your QGLWidget subclass:</para>
                <para> QGLFormat fmt;</para>
                <para> fmt.setDoubleBuffer(false);                 // single buffer</para>
                <para> fmt.setDirectRendering(false);              // software rendering</para>
                <para> MyGLWidget* myWidget = new MyGLWidget(fmt, ...);</para>
                <para>After the widget has been created, you can find out which of the requested features the system was able to provide:</para>
                <para> QGLFormat fmt;</para>
                <para> fmt.setOverlay(true);</para>
                <para> fmt.setStereo(true);</para>
                <para> MyGLWidget* myWidget = new MyGLWidget(fmt, ...);</para>
                <para> if (!myWidget-&gt;format().stereo()) {</para>
                <para>     // ok, goggles off</para>
                <para>     if (!myWidget-&gt;format().hasOverlay()) {</para>
                <para>         qFatal("Cool hardware required");</para>
                <para>     }</para>
                <para> }</para>
                <para>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</para>
                <para>
                </para>
                <para>See also QGLContext and QGLWidget.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLFormat.#ctor">
            <summary>
                <para>Constructs a QGLFormat object with the following default settings:</para>
                <para>
                </para>
                <para>Double buffer: Enabled.</para>
                <para>Depth buffer: Enabled.</para>
                <para>RGBA: Enabled (i.e., color index disabled).</para>
                <para>Alpha channel: Disabled.</para>
                <para>Accumulator buffer: Disabled.</para>
                <para>Stencil buffer: Enabled.</para>
                <para>Stereo: Disabled.</para>
                <para>Direct rendering: Enabled.</para>
                <para>Overlay: Disabled.</para>
                <para>Plane: 0 (i.e., normal plane).</para>
                <para>Multisample buffers: Disabled.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.#ctor(QtOpenGL.QGLFormat)">
            <summary>
                <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.#ctor(QGL.FormatOption,System.Int32)">
            <summary>
                <para>Creates a QGLFormat object that is a copy of the current defaultFormat().</para>
                <para>If options is not 0, the default format is modified by the specified format options. The options parameter should be QGL::FormatOption values OR'ed together.</para>
                <para>This constructor makes it easy to specify a certain desired format in classes derived from QGLWidget, for example:</para>
                <para> // The rendering in MyGLWidget depends on using</para>
                <para> // stencil buffer and alpha channel</para>
                <para> MyGLWidget::MyGLWidget(QWidget* parent)</para>
                <para>     : QGLWidget(QGLFormat(QGL::StencilBuffer | QGL::AlphaChannel), parent)</para>
                <para> {</para>
                <para>     if (!format().stencil())</para>
                <para>         qWarning("Could not get stencil buffer; results will be suboptimal");</para>
                <para>     if (!format().alpha())</para>
                <para>         qWarning("Could not get alpha channel; results will be suboptimal");</para>
                <para>     ...</para>
                <para> }</para>
                <para>Note that there are QGL::FormatOption values to turn format settings both on and off, e.g. QGL::DepthBuffer and QGL::NoDepthBuffer, QGL::DirectRendering and QGL::IndirectRendering, etc.</para>
                <para>The plane parameter defaults to 0 and is the plane which this format should be associated with. Not all OpenGL implementations supports overlay/underlay rendering planes.</para>
                <para>See also defaultFormat(), setOption(), and setPlane().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFormat.OpenGLContextProfile">
            <summary>
                <para>This enum describes the OpenGL context profiles that can be specified for contexts implementing OpenGL version 3.2 or higher. These profiles are different from OpenGL ES profiles.</para>
                <para>This enum was introduced or modified in Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLContextProfile.CompatibilityProfile">
            <summary>
                <para>Functionality from earlier OpenGL versions is available.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLContextProfile.CoreProfile">
            <summary>
                <para>Functionality deprecated in OpenGL version 3.0 is not available.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLContextProfile.NoProfile">
            <summary>
                <para>OpenGL version is lower than 3.2.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFormat.OpenGLVersionFlag">
            <summary>
                <para>This enum describes the various OpenGL versions that are recognized by Qt. Use the QGLFormat::openGLVersionFlags() function to identify which versions that are supported at runtime.</para>
                <para>See also http://www.opengl.org for more information about the different revisions of OpenGL.</para>
                <para>This enum was introduced or modified in Qt 4.2.</para>
                <para>
                </para>
                <para>See also openGLVersionFlags().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_CommonLite_Version_1_0">
            <summary>
                <para>OpenGL ES version 1.0 Common Lite or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_CommonLite_Version_1_1">
            <summary>
                <para>OpenGL ES version 1.1 Common Lite or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_Common_Version_1_0">
            <summary>
                <para>OpenGL ES version 1.0 Common or higher is present. The Common profile supports all the features of Common Lite.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_Common_Version_1_1">
            <summary>
                <para>OpenGL ES version 1.1 Common or higher is present. The Common profile supports all the features of Common Lite.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_Version_2_0">
            <summary>
                <para>OpenGL ES version 2.0 or higher is present. Note that OpenGL ES version 2.0 does not support all the features of OpenGL ES 1.x. So if OpenGL_ES_Version_2_0 is returned, none of the ES 1.x flags are returned.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_1">
            <summary>
                <para>OpenGL version 1.1 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_2">
            <summary>
                <para>OpenGL version 1.2 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_3">
            <summary>
                <para>OpenGL version 1.3 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_4">
            <summary>
                <para>OpenGL version 1.4 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_5">
            <summary>
                <para>OpenGL version 1.5 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_2_0">
            <summary>
                <para>OpenGL version 2.0 or higher is present. Note that version 2.0 supports all the functionality of version 1.5.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_2_1">
            <summary>
                <para>OpenGL version 2.1 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_0">
            <summary>
                <para>OpenGL version 3.0 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_1">
            <summary>
                <para>OpenGL version 3.1 or higher is present. Note that OpenGL version 3.1 or higher does not necessarily support all the features of version 3.0 and lower.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_2">
            <summary>
                <para>OpenGL version 3.2 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_3">
            <summary>
                <para>OpenGL version 3.3 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_4_0">
            <summary>
                <para>OpenGL version 4.0 or higher is present.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_None">
            <summary>
                <para>If no OpenGL is present or if no OpenGL context is current.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Accum">
            <summary>
                <para>Returns true if the accumulation buffer is enabled; otherwise returns false. The accumulation buffer is disabled by default.</para>
                <para>If enable is true enables the accumulation buffer; otherwise disables the accumulation buffer.</para>
                <para>The accumulation buffer is disabled by default.</para>
                <para>The accumulation buffer is used to create blur effects and multiple exposures.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.AccumBufferSize">
            <summary>
                <para>Returns the accumulation buffer size.</para>
                <para>Set the preferred accumulation buffer size, where size is the bit depth for each RGBA component.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Alpha">
            <summary>
                <para>Returns true if the alpha buffer in the framebuffer is enabled; otherwise returns false. The alpha buffer is disabled by default.</para>
                <para>If enable is true enables the alpha buffer; otherwise disables the alpha buffer.</para>
                <para>The alpha buffer is disabled by default.</para>
                <para>The alpha buffer is typically used for implementing transparency or translucency. The A in RGBA specifies the transparency of a pixel.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.AlphaBufferSize">
            <summary>
                <para>Returns the alpha buffer size.</para>
                <para>Set the preferred alpha buffer size to size. This function implicitly enables the alpha channel.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.BlueBufferSize">
            <summary>
                <para>Returns the blue buffer size.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>Set the preferred blue buffer size to size.</para>
                <para>This function was introduced in Qt 4.2.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DefaultFormat">
            <summary>
                <para>Returns the default QGLFormat for the application. All QGLWidget objects that are created use this format unless another format is specified, e.g. when they are constructed.</para>
                <para>If no special default format has been set using setDefaultFormat(), the default format is the same as that created with QGLFormat().</para>
                <para>Sets a new default QGLFormat for the application to f. For example, to set single buffering as the default instead of double buffering, your main() might contain code like this:</para>
                <para> QApplication a(argc, argv);</para>
                <para> QGLFormat f;</para>
                <para> f.setDoubleBuffer(false);</para>
                <para> QGLFormat::setDefaultFormat(f);</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DefaultOverlayFormat">
            <summary>
                <para>Returns the default QGLFormat for overlay contexts.</para>
                <para>The default overlay format is:</para>
                <para>
                </para>
                <para>Double buffer: Disabled.</para>
                <para>Depth buffer: Disabled.</para>
                <para>RGBA: Disabled (i.e., color index enabled).</para>
                <para>Alpha channel: Disabled.</para>
                <para>Accumulator buffer: Disabled.</para>
                <para>Stencil buffer: Disabled.</para>
                <para>Stereo: Disabled.</para>
                <para>Direct rendering: Enabled.</para>
                <para>Overlay: Disabled.</para>
                <para>Multisample buffers: Disabled.</para>
                <para>Plane: 1 (i.e., first overlay plane).</para>
                <para>
                </para>
                <para>Sets a new default QGLFormat for overlay contexts to f. This format is used whenever a QGLWidget is created with a format that hasOverlay() enabled.</para>
                <para>For example, to get a double buffered overlay context (if available), use code like this:</para>
                <para> QGLFormat f = QGLFormat::defaultOverlayFormat();</para>
                <para> f.setDoubleBuffer(true);</para>
                <para> QGLFormat::setDefaultOverlayFormat(f);</para>
                <para>As usual, you can find out after widget creation whether the underlying OpenGL system was able to provide the requested specification:</para>
                <para> // ...continued from above</para>
                <para> MyGLWidget* myWidget = new MyGLWidget(QGLFormat(QGL::HasOverlay), ...);</para>
                <para> if (myWidget-&gt;format().hasOverlay()) {</para>
                <para>     // Yes, we got an overlay, let's check _its_ format:</para>
                <para>     QGLContext* olContext = myWidget-&gt;overlayContext();</para>
                <para>     if (olContext-&gt;format().doubleBuffer())</para>
                <para>         ; // yes, we got a double buffered overlay</para>
                <para>     else</para>
                <para>         ; // no, only single buffered overlays are available</para>
                <para> }</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Depth">
            <summary>
                <para>Returns true if the depth buffer is enabled; otherwise returns false. The depth buffer is enabled by default.</para>
                <para>If enable is true enables the depth buffer; otherwise disables the depth buffer.</para>
                <para>The depth buffer is enabled by default.</para>
                <para>The purpose of a depth buffer (or Z-buffering) is to remove hidden surfaces. Pixels are assigned Z values based on the distance to the viewer. A pixel with a high Z value is closer to the viewer than a pixel with a low Z value. This information is used to decide whether to draw a pixel or not.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DepthBufferSize">
            <summary>
                <para>Returns the depth buffer size.</para>
                <para>Set the minimum depth buffer size to size.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DirectRendering">
            <summary>
                <para>Returns true if direct rendering is enabled; otherwise returns false.</para>
                <para>Direct rendering is enabled by default.</para>
                <para>If enable is true enables direct rendering; otherwise disables direct rendering.</para>
                <para>Direct rendering is enabled by default.</para>
                <para>Enabling this option will make OpenGL bypass the underlying window system and render directly from hardware to the screen, if this is supported by the system.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DoubleBuffer">
            <summary>
                <para>Returns true if double buffering is enabled; otherwise returns false. Double buffering is enabled by default.</para>
                <para>If enable is true sets double buffering; otherwise sets single buffering.</para>
                <para>Double buffering is enabled by default.</para>
                <para>Double buffering is a technique where graphics are rendered on an off-screen buffer and not directly to the screen. When the drawing has been completed, the program calls a swapBuffers() function to exchange the screen contents with the buffer. The result is flicker-free drawing and often better performance.</para>
                <para>Note that single buffered contexts are currently not supported with EGL.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.GreenBufferSize">
            <summary>
                <para>Returns the green buffer size.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>Set the preferred green buffer size to size.</para>
                <para>This function was introduced in Qt 4.2.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Plane">
            <summary>
                <para>Returns the plane of this format. The default for normal formats is 0, which means the normal plane. The default for overlay formats is 1, which is the first overlay plane.</para>
                <para>Sets the requested plane to plane. 0 is the normal plane, 1 is the first overlay plane, 2 is the second overlay plane, etc.; -1, -2, etc. are underlay planes.</para>
                <para>Note that in contrast to other format specifications, the plane specifications will be matched exactly. This means that if you specify a plane that the underlying OpenGL system cannot provide, an invalid QGLWidget will be created.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Profile">
            <summary>
                <para>Returns the OpenGL context profile.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>Set the OpenGL context profile to profile. The profile is ignored if the requested OpenGL version is less than 3.2.</para>
                <para>This function was introduced in Qt 4.7.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.RedBufferSize">
            <summary>
                <para>Returns the red buffer size.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>Set the preferred red buffer size to size.</para>
                <para>This function was introduced in Qt 4.2.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Rgba">
            <summary>
                <para>Returns true if RGBA color mode is set. Returns false if color index mode is set. The default color mode is RGBA.</para>
                <para>If enable is true sets RGBA mode. If enable is false sets color index mode.</para>
                <para>The default color mode is RGBA.</para>
                <para>RGBA is the preferred mode for most OpenGL applications. In RGBA color mode you specify colors as red + green + blue + alpha quadruplets.</para>
                <para>In color index mode you specify an index into a color lookup table.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.SampleBuffers">
            <summary>
                <para>Returns true if multisample buffer support is enabled; otherwise returns false.</para>
                <para>The multisample buffer is disabled by default.</para>
                <para>If enable is true, a GL context with multisample buffer support is picked; otherwise ignored.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Samples">
            <summary>
                <para>Returns the number of samples per pixel when multisampling is enabled. By default, the highest number of samples that is available is used.</para>
                <para>Set the preferred number of samples per pixel when multisampling is enabled to numSamples. By default, the highest number of samples available is used.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Stencil">
            <summary>
                <para>Returns true if the stencil buffer is enabled; otherwise returns false. The stencil buffer is enabled by default.</para>
                <para>If enable is true enables the stencil buffer; otherwise disables the stencil buffer.</para>
                <para>The stencil buffer is enabled by default.</para>
                <para>The stencil buffer masks certain parts of the drawing area so that masked parts are not drawn on.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.StencilBufferSize">
            <summary>
                <para>Returns the stencil buffer size.</para>
                <para>Set the preferred stencil buffer size to size.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Stereo">
            <summary>
                <para>Returns true if stereo buffering is enabled; otherwise returns false. Stereo buffering is disabled by default.</para>
                <para>If enable is true enables stereo buffering; otherwise disables stereo buffering.</para>
                <para>Stereo buffering is disabled by default.</para>
                <para>Stereo buffering provides extra color buffers to generate left-eye and right-eye images.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.SwapInterval">
            <summary>
                <para>Returns the currently set swap interval. -1 is returned if setting the swap interval isn't supported in the system GL implementation.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>Set the preferred swap interval. This can be used to sync the GL drawing into a system window to the vertical refresh of the screen. Setting an interval value of 0 will turn the vertical refresh syncing off, any value higher than 0 will turn the vertical syncing on.</para>
                <para>Under Windows and under X11, where the WGL_EXT_swap_control and GLX_SGI_video_sync extensions are used, the interval parameter can be used to set the minimum number of video frames that are displayed before a buffer swap will occur. In effect, setting the interval to 10, means there will be 10 vertical retraces between every buffer swap.</para>
                <para>Under Windows the WGL_EXT_swap_control extension has to be present, and under X11 the GLX_SGI_video_sync extension has to be present.</para>
                <para>This function was introduced in Qt 4.2.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.HasOpenGL">
            <summary>
                <para>Returns true if the window system has any OpenGL support; otherwise returns false.</para>
                <para>Warning: This function must not be called until the QApplication object has been created.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.HasOpenGLOverlays">
            <summary>
                <para>Returns true if the window system supports OpenGL overlays; otherwise returns false.</para>
                <para>Warning: This function must not be called until the QApplication object has been created.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.HasOverlay">
            <summary>
                <para>Returns true if overlay plane is enabled; otherwise returns false.</para>
                <para>Overlay is disabled by default.</para>
                <para>See also setOverlay().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.MajorVersion">
            <summary>
                <para>Returns the OpenGL major version.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also setVersion() and minorVersion().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.MinorVersion">
            <summary>
                <para>Returns the OpenGL minor version.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also setVersion() and majorVersion().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.OpenGLVersionFlags">
            <summary>
                <para>Identifies, at runtime, which OpenGL versions that are supported by the current platform.</para>
                <para>Note that if OpenGL version 1.5 is supported, its predecessors (i.e., version 1.4 and lower) are also supported. To identify the support of a particular feature, like multi texturing, test for the version in which the feature was first introduced (i.e., version 1.3 in the case of multi texturing) to adapt to the largest possible group of runtime platforms.</para>
                <para>This function needs a valid current OpenGL context to work; otherwise it will return OpenGL_Version_None.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also hasOpenGL() and hasOpenGLOverlays().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.SetOption(QGL.FormatOption)">
            <summary>
                <para>Sets the format option to opt.</para>
                <para>See also testOption().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.SetOverlay(System.Boolean)">
            <summary>
                <para>If enable is true enables an overlay plane; otherwise disables the overlay plane.</para>
                <para>Enabling the overlay plane will cause QGLWidget to create an additional context in an overlay plane. See the QGLWidget documentation for further information.</para>
                <para>See also hasOverlay().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.SetVersion(System.Int32,System.Int32)">
            <summary>
                <para>Set the OpenGL version to the major and minor numbers. If a context compatible with the requested OpenGL version cannot be created, a context compatible with version 1.x is created instead.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also majorVersion() and minorVersion().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.TestOption(QGL.FormatOption)">
            <summary>
                <para>Returns true if format option opt is set; otherwise returns false.</para>
                <para>See also setOption().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.Finalize">
            <summary>
                <para>Destroys the QGLFormat.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.op_Inequality(QtOpenGL.QGLFormat,QtOpenGL.QGLFormat)">
            <summary>
                <para>Returns false if all the options of the two QGLFormat objects a and b are equal; otherwise returns true.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.op_Equality(QtOpenGL.QGLFormat,QtOpenGL.QGLFormat)">
            <summary>
                <para>Returns true if all the options of the two QGLFormat objects a and b are equal; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFramebufferObject">
            <summary>
            The QGLFramebufferObject class encapsulates an OpenGL framebuffer object.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QGLFramebufferObject class encapsulates an OpenGL framebuffer object, defined by the GL_EXT_framebuffer_object extension. In addition it provides a rendering surface that can be painted on with a QPainter, rendered to using native GL calls, or both. This surface can be bound and used as a regular texture in your own GL drawing code. By default, the QGLFramebufferObject class generates a 2D GL texture (using the GL_TEXTURE_2D target), which is used as the internal rendering target.</para>
                <para>It is important to have a current GL context when creating a QGLFramebufferObject, otherwise initialization will fail.</para>
                <para>OpenGL framebuffer objects and pbuffers (see QGLPixelBuffer) can both be used to render to offscreen surfaces, but there are a number of advantages with using framebuffer objects instead of pbuffers:</para>
                <para>
                </para>
                <para>A framebuffer object does not require a separate rendering context, so no context switching will occur when switching rendering targets. There is an overhead involved in switching targets, but in general it is cheaper than a context switch to a pbuffer.</para>
                <para>Rendering to dynamic textures (i.e. render-to-texture functionality) works on all platforms. No need to do explicit copy calls from a render buffer into a texture, as was necessary on systems that did not support the render_texture extension.</para>
                <para>It is possible to attach several rendering buffers (or texture objects) to the same framebuffer object, and render to all of them without doing a context switch.</para>
                <para>The OpenGL framebuffer extension is a pure GL extension with no system dependant WGL, CGL, or GLX parts. This makes using framebuffer objects more portable.</para>
                <para>
                </para>
                <para>When using a QPainter to paint to a QGLFramebufferObject you should take care that the QGLFramebufferObject is created with the CombinedDepthStencil attachment for QPainter to be able to render correctly. Note that you need to create a QGLFramebufferObject with more than one sample per pixel for primitives to be antialiased when drawing using a QPainter. To create a multisample framebuffer object you should use one of the constructors that take a QGLFramebufferObject parameter, and set the QGLFramebufferObject::samples() property to a non-zero value.</para>
                <para>When painting to a QGLFramebufferObject using QPainter, the state of the current GL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the GL state being reset to its original conditions, particularly the current shader program, GL viewport, texture units, and drawing modes.</para>
                <para>For multisample framebuffer objects a color render buffer is created, otherwise a texture with the specified texture target is created. The color render buffer or texture will have the specified internal format, and will be bound to the GL_COLOR_ATTACHMENT0 attachment in the framebuffer object.</para>
                <para>If you want to use a framebuffer object with multisampling enabled as a texture, you first need to copy from it to a regular framebuffer object using QGLContext::blitFramebuffer().</para>
                <para>
                </para>
                <para>Threading</para>
                <para>As of Qt 4.8, it's possible to draw into a QGLFramebufferObject using a QPainter in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work. Also, under X11, it's necessary to set the Qt::AA_X11InitThreads application attribute.</para>
                <para>
                </para>
                <para>See also Framebuffer Object Example.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize)">
            <summary>
                <para>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the size size. The texture is bound to the GL_COLOR_ATTACHMENT0 target in the framebuffer object.</para>
                <para>The target parameter is used to specify the GL texture target. The default target is GL_TEXTURE_2D. Keep in mind that GL_TEXTURE_2D textures must have a power of 2 width and height (e.g. 256x512), unless you are using OpenGL 2.0 or higher.</para>
                <para>By default, no depth and stencil buffers are attached. This behavior can be toggled using one of the overloaded constructors.</para>
                <para>The default internal texture format is GL_RGBA8 for desktop OpenGL, and GL_RGBA for OpenGL/ES.</para>
                <para>It is important that you have a current GL context set when creating the QGLFramebufferObject, otherwise the initialization will fail.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object of the given size based on the supplied format.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,QtOpenGL.QGLFramebufferObject.Attachment)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given size.</para>
                <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,QtOpenGL.QGLFramebufferObject.Attachment,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given size.</para>
                <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,QtOpenGL.QGLFramebufferObject.Attachment,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given size.</para>
                <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,System.Int32)">
            <summary>
                <para>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the size size. The texture is bound to the GL_COLOR_ATTACHMENT0 target in the framebuffer object.</para>
                <para>The target parameter is used to specify the GL texture target. The default target is GL_TEXTURE_2D. Keep in mind that GL_TEXTURE_2D textures must have a power of 2 width and height (e.g. 256x512), unless you are using OpenGL 2.0 or higher.</para>
                <para>By default, no depth and stencil buffers are attached. This behavior can be toggled using one of the overloaded constructors.</para>
                <para>The default internal texture format is GL_RGBA8 for desktop OpenGL, and GL_RGBA for OpenGL/ES.</para>
                <para>It is important that you have a current GL context set when creating the QGLFramebufferObject, otherwise the initialization will fail.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the given width and height.</para>
                <para>See also size() and texture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object of the given width and height based on the supplied format.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFramebufferObject.Attachment)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given width and height.</para>
                <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFramebufferObject.Attachment,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given width and height.</para>
                <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFramebufferObject.Attachment,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given width and height.</para>
                <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
                <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the given width and height.</para>
                <para>See also size() and texture().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFramebufferObject.Attachment">
            <summary>
                <para>This enum type is used to configure the depth and stencil buffers attached to the framebuffer object when it is created.</para>
                <para>This enum was introduced or modified in Qt 4.3.</para>
                <para>See also attachment().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFramebufferObject.Attachment.CombinedDepthStencil">
            <summary>
                <para>If the GL_EXT_packed_depth_stencil extension is present, a combined depth and stencil buffer is attached. If the extension is not present, only a depth buffer is attached.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFramebufferObject.Attachment.Depth">
            <summary>
                <para>A depth buffer is attached to the framebuffer object.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFramebufferObject.Attachment.NoAttachment">
            <summary>
                <para>No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.attachment">
            <summary>
                <para>Returns the status of the depth and stencil buffers attached to this framebuffer object.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Format">
            <summary>
                <para>Returns the format of this framebuffer object.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Handle">
            <summary>
                <para>Returns the GL framebuffer object handle for this framebuffer object (returned by the glGenFrameBuffersEXT() function). This handle can be used to attach new images or buffers to the framebuffer. The user is responsible for cleaning up and destroying these objects.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.HasOpenGLFramebufferBlit">
            <summary>
                <para>Returns true if the OpenGL GL_EXT_framebuffer_blit extension is present on this system; otherwise returns false.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also blitFramebuffer().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.HasOpenGLFramebufferObjects">
            <summary>
                <para>Returns true if the OpenGL GL_EXT_framebuffer_object extension is present on this system; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.IsBound">
            <summary>
                <para>Returns true if the framebuffer object is currently bound to a context, otherwise false is returned.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.IsValid">
            <summary>
                <para>Returns true if the framebuffer object is valid.</para>
                <para>The framebuffer can become invalid if the initialization process fails, the user attaches an invalid buffer to the framebuffer object, or a non-power of two width/height is specified as the texture size if the texture target is GL_TEXTURE_2D. The non-power of two limitation does not apply if the OpenGL version is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension is present.</para>
                <para>The framebuffer can also become invalid if the QGLContext that the framebuffer was created within is destroyed and there are no other shared contexts that can take over ownership of the framebuffer.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.PaintEngine">
            <summary>
                <para>Reimplemented from QPaintDevice::paintEngine().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Release">
            <summary>
                <para>Switches rendering back to the default, windowing system provided framebuffer. Returns true upon success, false otherwise.</para>
                <para>See also bind().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Size">
            <summary>
                <para>Returns the size of the texture attached to this framebuffer object.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Texture">
            <summary>
                <para>Returns the texture id for the texture attached as the default rendering target in this framebuffer object. This texture id can be bound as a normal texture in your own GL code.</para>
                <para>If a multisample framebuffer object is used then the value returned from this function will be invalid.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.Bind">
            <summary>
                <para>Switches rendering from the default, windowing system provided framebuffer to this framebuffer object. Returns true upon success, false otherwise.</para>
                <para>See also release().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.BlitFramebuffer(QtOpenGL.QGLFramebufferObject,QtCore.QRect,QtOpenGL.QGLFramebufferObject,QtCore.QRect)">
            <summary>
                <para>Blits from the sourceRect rectangle in the source framebuffer object to the targetRect rectangle in the target framebuffer object.</para>
                <para>If source or target is 0, the default framebuffer will be used instead of a framebuffer object as source or target respectively.</para>
                <para>The buffers parameter should be a mask consisting of any combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. Any buffer type that is not present both in the source and target buffers is ignored.</para>
                <para>The sourceRect and targetRect rectangles may have different sizes; in this case buffers should not contain GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT. The filter parameter should be set to GL_LINEAR or GL_NEAREST, and specifies whether linear or nearest interpolation should be used when scaling is performed.</para>
                <para>If source equals target a copy is performed within the same buffer. Results are undefined if the source and target rectangles overlap and have different sizes. The sizes must also be the same if any of the framebuffer objects are multisample framebuffers.</para>
                <para>Note that the scissor test will restrict the blit area if enabled.</para>
                <para>This function will have no effect unless hasOpenGLFramebufferBlit() returns true.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also hasOpenGLFramebufferBlit().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.BlitFramebuffer(QtOpenGL.QGLFramebufferObject,QtCore.QRect,QtOpenGL.QGLFramebufferObject,QtCore.QRect,System.Int32)">
            <summary>
                <para>Blits from the sourceRect rectangle in the source framebuffer object to the targetRect rectangle in the target framebuffer object.</para>
                <para>If source or target is 0, the default framebuffer will be used instead of a framebuffer object as source or target respectively.</para>
                <para>The buffers parameter should be a mask consisting of any combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. Any buffer type that is not present both in the source and target buffers is ignored.</para>
                <para>The sourceRect and targetRect rectangles may have different sizes; in this case buffers should not contain GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT. The filter parameter should be set to GL_LINEAR or GL_NEAREST, and specifies whether linear or nearest interpolation should be used when scaling is performed.</para>
                <para>If source equals target a copy is performed within the same buffer. Results are undefined if the source and target rectangles overlap and have different sizes. The sizes must also be the same if any of the framebuffer objects are multisample framebuffers.</para>
                <para>Note that the scissor test will restrict the blit area if enabled.</para>
                <para>This function will have no effect unless hasOpenGLFramebufferBlit() returns true.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also hasOpenGLFramebufferBlit().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.BlitFramebuffer(QtOpenGL.QGLFramebufferObject,QtCore.QRect,QtOpenGL.QGLFramebufferObject,QtCore.QRect,System.Int32,System.Int32)">
            <summary>
                <para>Blits from the sourceRect rectangle in the source framebuffer object to the targetRect rectangle in the target framebuffer object.</para>
                <para>If source or target is 0, the default framebuffer will be used instead of a framebuffer object as source or target respectively.</para>
                <para>The buffers parameter should be a mask consisting of any combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. Any buffer type that is not present both in the source and target buffers is ignored.</para>
                <para>The sourceRect and targetRect rectangles may have different sizes; in this case buffers should not contain GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT. The filter parameter should be set to GL_LINEAR or GL_NEAREST, and specifies whether linear or nearest interpolation should be used when scaling is performed.</para>
                <para>If source equals target a copy is performed within the same buffer. Results are undefined if the source and target rectangles overlap and have different sizes. The sizes must also be the same if any of the framebuffer objects are multisample framebuffers.</para>
                <para>Note that the scissor test will restrict the blit area if enabled.</para>
                <para>This function will have no effect unless hasOpenGLFramebufferBlit() returns true.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also hasOpenGLFramebufferBlit().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.DrawTexture(QtCore.QRectF,System.UInt32)">
            <summary>
                <para>Draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>The framebuffer object should be bound when calling this function.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.DrawTexture(QtCore.QPointF,System.UInt32)">
            <summary>
                <para>Draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>The framebuffer object should be bound when calling this function.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.DrawTexture(QtCore.QRectF,System.UInt32,System.Int32)">
            <summary>
                <para>Draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>The framebuffer object should be bound when calling this function.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.DrawTexture(QtCore.QPointF,System.UInt32,System.Int32)">
            <summary>
                <para>Draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>The framebuffer object should be bound when calling this function.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.Metric(QtGui.QPaintDevice.PaintDeviceMetric)">
            <summary>
                <para>Reimplemented from QPaintDevice::metric().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.ToImage">
            <summary>
                <para>Returns the contents of this framebuffer object as a QImage.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.Finalize">
            <summary>
                <para>Destroys the framebuffer object and frees any allocated resources.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFramebufferObjectFormat">
            <summary>
            The QGLFramebufferObjectFormat class specifies the format of an OpenGL framebuffer object.
            </summary>
            <remarks>
                <para>
                </para>
                <para>A framebuffer object has several characteristics:</para>
                <para>
                </para>
                <para>Number of samples per pixels.</para>
                <para>Depth and/or stencil attachments.</para>
                <para>Texture target.</para>
                <para>Internal texture format.</para>
                <para>
                </para>
                <para>Note that the desired attachments or number of samples per pixels might not be supported by the hardware driver. Call QGLFramebufferObject::format() after creating a QGLFramebufferObject to find the exact format that was used to create the frame buffer object.</para>
                <para>
                </para>
                <para>See also QGLFramebufferObject.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.#ctor">
            <summary>
                <para>Creates a QGLFramebufferObjectFormat object for specifying the format of an OpenGL framebuffer object.</para>
                <para>By default the format specifies a non-multisample framebuffer object with no attachments, texture target GL_TEXTURE_2D, and internal format GL_RGBA8. On OpenGL/ES systems, the default internal format is GL_RGBA.</para>
                <para>See also samples(), attachment(), and internalTextureFormat().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.#ctor(QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
                <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.Attachment">
            <summary>
                <para>Returns the configuration of the depth and stencil buffers attached to a framebuffer object. The default is QGLFramebufferObject::NoAttachment.</para>
                <para>Sets the attachment configuration of a framebuffer object to attachment.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.InternalTextureFormat">
            <summary>
                <para>Returns the internal format of a framebuffer object's texture or multisample framebuffer object's color buffer. The default is GL_RGBA8 on desktop OpenGL systems, and GL_RGBA on OpenGL/ES systems.</para>
                <para>Sets the internal format of a framebuffer object's texture or multisample framebuffer object's color buffer to internalTextureFormat.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.Mipmap">
            <summary>
                <para>Returns true if mipmapping is enabled.</para>
                <para>This function was introduced in Qt 4.8.</para>
                <para>Enables mipmapping if enabled is true; otherwise disables it.</para>
                <para>Mipmapping is disabled by default.</para>
                <para>If mipmapping is enabled, additional memory will be allocated for the mipmap levels. The mipmap levels can be updated by binding the texture and calling glGenerateMipmap(). Mipmapping cannot be enabled for multisampled framebuffer objects.</para>
                <para>This function was introduced in Qt 4.8.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.Samples">
            <summary>
                <para>Returns the number of samples per pixel if a framebuffer object is a multisample framebuffer object. Otherwise, returns 0. The default value is 0.</para>
                <para>Sets the number of samples per pixel for a multisample framebuffer object to samples. The default sample count of 0 represents a regular non-multisample framebuffer object.</para>
                <para>If the desired amount of samples per pixel is not supported by the hardware then the maximum number of samples per pixel will be used. Note that multisample framebuffer objects can not be bound as textures. Also, the GL_EXT_framebuffer_multisample extension is required to create a framebuffer with more than one sample per pixel.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.TextureTarget">
            <summary>
                <para>Returns the texture target of the texture attached to a framebuffer object. Ignored for multisample framebuffer objects. The default is GL_TEXTURE_2D.</para>
                <para>Sets the texture target of the texture attached to a framebuffer object to target. Ignored for multisample framebuffer objects.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.Finalize">
            <summary>
                <para>Destroys the QGLFramebufferObjectFormat.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.op_Inequality(QtOpenGL.QGLFramebufferObjectFormat,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
                <para>Returns false if all the options of this framebuffer object format are the same as other; otherwise returns true.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.op_Equality(QtOpenGL.QGLFramebufferObjectFormat,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
                <para>Returns true if all the options of this framebuffer object format are the same as other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLPixelBuffer">
            <summary>
            The QGLPixelBuffer class encapsulates an OpenGL pbuffer.
            </summary>
            <remarks>
                <para>
                </para>
                <para>Rendering into a pbuffer is normally done using full hardware acceleration. This can be significantly faster than rendering into a QPixmap.</para>
                <para>There are three approaches to using this class:</para>
                <para>
                </para>
                <para>We can draw into the pbuffer and convert it to a QImage using toImage(). This is normally much faster than calling QGLWidget::renderPixmap().</para>
                <para>We can draw into the pbuffer and copy the contents into an OpenGL texture using updateDynamicTexture(). This allows us to create dynamic textures and works on all systems with pbuffer support.</para>
                <para>On systems that support it, we can bind the pbuffer to an OpenGL texture. The texture is then updated automatically when the pbuffer contents change, eliminating the need for additional copy operations. This is supported only on Windows and Mac OS X systems that provide the render_texture extension. Note that under Windows, a multi-sampled pbuffer can't be used in conjunction with the render_texture extension. If a multi-sampled pbuffer is requested under Windows, the render_texture extension is turned off for that pbuffer.</para>
                <para>
                </para>
                <para>
                </para>
                <para>Threading</para>
                <para>As of Qt 4.8, it's possible to render into a QGLPixelBuffer using a QPainter in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work. Also, under X11, it's necessary to set the Qt::AA_X11InitThreads application attribute.</para>
                <para>Pbuffers are provided by the OpenGL pbuffer extension; call hasOpenGLPbuffer() to find out if the system provides pbuffers.</para>
                <para>
                </para>
                <para>See also Pbuffers Example.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(QtCore.QSize)">
            <summary>
                <para>Constructs an OpenGL pbuffer of the given size. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
                <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
                <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(QtCore.QSize,QtOpenGL.QGLFormat,QtOpenGL.QGLWidget)">
            <summary>
                <para>Constructs an OpenGL pbuffer of the given size. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
                <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
                <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL pbuffer with the width and height. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
                <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
                <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFormat,QtOpenGL.QGLWidget)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Constructs an OpenGL pbuffer with the width and height. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
                <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
                <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.Format">
            <summary>
                <para>Returns the format of the pbuffer. The format may be different from the one that was requested.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.Handle">
            <summary>
                <para>Returns the native pbuffer handle.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.HasOpenGLPbuffers">
            <summary>
                <para>Returns true if the OpenGL pbuffer extension is present on this system; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.IsValid">
            <summary>
                <para>Returns true if this pbuffer is valid; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.PaintEngine">
            <summary>
                <para>Reimplemented from QPaintDevice::paintEngine().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.Size">
            <summary>
                <para>Returns the size of the pbuffer.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(QtGui.QImage)">
            <summary>
                <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
                <para>The target parameter specifies the texture target.</para>
                <para>Equivalent to calling QGLContext::bindTexture().</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(QtGui.QPixmap)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Generates and binds a 2D GL texture based on pixmap.</para>
                <para>Equivalent to calling QGLContext::bindTexture().</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(QtGui.QImage,System.Int32)">
            <summary>
                <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
                <para>The target parameter specifies the texture target.</para>
                <para>Equivalent to calling QGLContext::bindTexture().</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(QtGui.QPixmap,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Generates and binds a 2D GL texture based on pixmap.</para>
                <para>Equivalent to calling QGLContext::bindTexture().</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Reads the DirectDrawSurface (DDS) compressed file fileName and generates a 2D GL texture from it.</para>
                <para>Equivalent to calling QGLContext::bindTexture().</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindToDynamicTexture(System.UInt32)">
            <summary>
                <para>Binds the texture specified by texture_id to this pbuffer. Returns true on success; otherwise returns false.</para>
                <para>The texture must be of the same size and format as the pbuffer.</para>
                <para>To unbind the texture, call releaseFromDynamicTexture(). While the texture is bound, it is updated automatically when the pbuffer contents change, eliminating the need for additional copy operations.</para>
                <para>Example:</para>
                <para> QGLPixelBuffer pbuffer(...);</para>
                <para> ...</para>
                <para> pbuffer.makeCurrent();</para>
                <para> GLuint dynamicTexture = pbuffer.generateDynamicTexture();</para>
                <para> pbuffer.bindToDynamicTexture(dynamicTexture);</para>
                <para> ...</para>
                <para> pbuffer.releaseFromDynamicTexture();</para>
                <para>Warning: This function uses the render_texture extension, which is currently not supported under X11. An alternative that works on all systems (including X11) is to manually copy the pbuffer contents to a texture using updateDynamicTexture().</para>
                <para>Warning: For the bindToDynamicTexture() call to succeed on the Mac OS X, the pbuffer needs a shared context, i.e. the QGLPixelBuffer must be created with a share widget.</para>
                <para>See also generateDynamicTexture() and releaseFromDynamicTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DeleteTexture(System.UInt32)">
            <summary>
                <para>Removes the texture identified by texture_id from the texture cache.</para>
                <para>Equivalent to calling QGLContext::deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DoneCurrent">
            <summary>
                <para>Makes no context the current OpenGL context. Returns true on success; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DrawTexture(QtCore.QRectF,System.UInt32)">
            <summary>
                <para>Draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DrawTexture(QtCore.QPointF,System.UInt32)">
            <summary>
                <para>Draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget parameter should be a 2D texture target.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DrawTexture(QtCore.QRectF,System.UInt32,System.Int32)">
            <summary>
                <para>Draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DrawTexture(QtCore.QPointF,System.UInt32,System.Int32)">
            <summary>
                <para>Draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget parameter should be a 2D texture target.</para>
                <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.GenerateDynamicTexture">
            <summary>
                <para>Generates and binds a 2D GL texture that is the same size as the pbuffer, and returns the texture's ID. This can be used in conjunction with bindToDynamicTexture() and updateDynamicTexture().</para>
                <para>See also size().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.MakeCurrent">
            <summary>
                <para>Makes this pbuffer the current OpenGL rendering context. Returns true on success; otherwise returns false.</para>
                <para>See also QGLContext::makeCurrent() and doneCurrent().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.Metric(QtGui.QPaintDevice.PaintDeviceMetric)">
            <summary>
                <para>Reimplemented from QPaintDevice::metric().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.ReleaseFromDynamicTexture">
            <summary>
                <para>Releases the pbuffer from any previously bound texture.</para>
                <para>See also bindToDynamicTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.ToImage">
            <summary>
                <para>Returns the contents of the pbuffer as a QImage.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.UpdateDynamicTexture(System.UInt32)">
            <summary>
                <para>Copies the pbuffer contents into the texture specified with texture_id.</para>
                <para>The texture must be of the same size and format as the pbuffer.</para>
                <para>Example:</para>
                <para> QGLPixelBuffer pbuffer(...);</para>
                <para> ...</para>
                <para> pbuffer.makeCurrent();</para>
                <para> GLuint dynamicTexture = pbuffer.generateDynamicTexture();</para>
                <para> ...</para>
                <para> pbuffer.updateDynamicTexture(dynamicTexture);</para>
                <para>An alternative on Windows and Mac OS X systems that support the render_texture extension is to use bindToDynamicTexture() to get dynamic updates of the texture.</para>
                <para>See also generateDynamicTexture() and bindToDynamicTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.Finalize">
            <summary>
                <para>Destroys the pbuffer and frees any allocated resources.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLShader">
            <summary>
            The QGLShader class allows OpenGL shaders to be compiled.
            </summary>
            <remarks>
                <para>
                </para>
                <para>This class supports shaders written in the OpenGL Shading Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).</para>
                <para>QGLShader and QGLShaderProgram shelter the programmer from the details of compiling and linking vertex and fragment shaders.</para>
                <para>
                </para>
                <para>See also QGLShaderProgram.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLShader.#ctor(QtOpenGL.QGLShader.ShaderTypeBit,QtCore.QObject)">
            <summary>
                <para>Constructs a new QGLShader object of the specified type and attaches it to parent. If shader programs are not supported, QGLShaderProgram::hasOpenGLShaderPrograms() will return false.</para>
                <para>This constructor is normally followed by a call to compileSourceCode() or compileSourceFile().</para>
                <para>The shader will be associated with the current QGLContext.</para>
                <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.#ctor(QtOpenGL.QGLShader.ShaderTypeBit,QtOpenGL.QGLContext,QtCore.QObject)">
            <summary>
                <para>Constructs a new QGLShader object of the specified type and attaches it to parent. If shader programs are not supported, then QGLShaderProgram::hasOpenGLShaderPrograms() will return false.</para>
                <para>This constructor is normally followed by a call to compileSourceCode() or compileSourceFile().</para>
                <para>The shader will be associated with context.</para>
                <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLShader.ShaderTypeBit">
            <summary>
                <para>This enum specifies the type of QGLShader that is being created.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLShader.ShaderTypeBit.Fragment">
            <summary>
                <para>Fragment shader written in the OpenGL Shading Language (GLSL).</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLShader.ShaderTypeBit.Geometry">
            <summary>
                <para>Geometry shaders written in the OpenGL Shading Language (GLSL), based on the GL_EXT_geometry_shader4 extension.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLShader.ShaderTypeBit.Vertex">
            <summary>
                <para>Vertex shader written in the OpenGL Shading Language (GLSL).</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.IsCompiled">
            <summary>
                <para>Returns true if this shader has been compiled; false otherwise.</para>
                <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.Log">
            <summary>
                <para>Returns the errors and warnings that occurred during the last compile.</para>
                <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.ShaderId">
            <summary>
                <para>Returns the OpenGL identifier associated with this shader.</para>
                <para>See also QGLShaderProgram::programId().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.ShaderType">
            <summary>
                <para>Returns the type of this shader.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.SourceCode">
            <summary>
                <para>Returns the source code for this shader.</para>
                <para>See also compileSourceCode().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.CompileSourceCode(QtCore.QByteArray)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the source code for this shader and compiles it. Returns true if the source was successfully compiled, false otherwise.</para>
                <para>See also compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.CompileSourceCode(System.String)">
            <summary>
                <para>Sets the source code for this shader and compiles it. Returns true if the source was successfully compiled, false otherwise.</para>
                <para>See also compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.CompileSourceFile(System.String)">
            <summary>
                <para>Sets the source code for this shader to the contents of fileName and compiles it. Returns true if the file could be opened and the source compiled, false otherwise.</para>
                <para>See also compileSourceCode().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.HasOpenGLShaders(QtOpenGL.QGLShader.ShaderTypeBit,QtOpenGL.QGLContext)">
            <summary>
                <para>Returns true if shader programs of type type are supported on this system; false otherwise.</para>
                <para>The context is used to resolve the GLSL extensions. If context is null, then QGLContext::currentContext() is used.</para>
                <para>This function was introduced in Qt 4.7.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.Finalize">
            <summary>
                <para>Deletes this shader. If the shader has been attached to a QGLShaderProgram object, then the actual shader will stay around until the QGLShaderProgram is destroyed.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLShaderProgram">
            <summary>
            The QGLShaderProgram class allows OpenGL shader programs to be linked and used.
            </summary>
            <remarks>
                <para>
                </para>
                <para>
                </para>
                <para>Introduction</para>
                <para>This class supports shader programs written in the OpenGL Shading Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).</para>
                <para>QGLShader and QGLShaderProgram shelter the programmer from the details of compiling and linking vertex and fragment shaders.</para>
                <para>The following example creates a vertex shader program using the supplied source code. Once compiled and linked, the shader program is activated in the current QGLContext by calling QGLShaderProgram::bind():</para>
                <para> QGLShader shader(QGLShader::Vertex);</para>
                <para> shader.compileSourceCode(code);</para>
                <para>
                </para>
                <para> QGLShaderProgram program(context);</para>
                <para> program.addShader(shader);</para>
                <para> program.link();</para>
                <para>
                </para>
                <para> program.bind();</para>
                <para>
                </para>
                <para>Writing portable shaders</para>
                <para>Shader programs can be difficult to reuse across OpenGL implementations because of varying levels of support for standard vertex attributes and uniform variables. In particular, GLSL/ES lacks all of the standard variables that are present on desktop OpenGL systems: gl_Vertex, gl_Normal, gl_Color, and so on. Desktop OpenGL lacks the variable qualifiers highp, mediump, and lowp.</para>
                <para>The QGLShaderProgram class makes the process of writing portable shaders easier by prefixing all shader programs with the following lines on desktop OpenGL:</para>
                <para> #define highp</para>
                <para> #define mediump</para>
                <para> #define lowp</para>
                <para>This makes it possible to run most GLSL/ES shader programs on desktop systems. The programmer should restrict themselves to just features that are present in GLSL/ES, and avoid standard variable names that only work on the desktop.</para>
                <para>
                </para>
                <para>Simple shader example</para>
                <para> program.addShaderFromSourceCode(QGLShader::Vertex,</para>
                <para>     "attribute highp vec4 vertex;\\n"</para>
                <para>     "uniform highp mat4 matrix;\\n"</para>
                <para>     "void main(void)\\n"</para>
                <para>     "{\\n"</para>
                <para>     "   gl_Position = matrix * vertex;\\n"</para>
                <para>     "}");</para>
                <para> program.addShaderFromSourceCode(QGLShader::Fragment,</para>
                <para>     "uniform mediump vec4 color;\\n"</para>
                <para>     "void main(void)\\n"</para>
                <para>     "{\\n"</para>
                <para>     "   gl_FragColor = color;\\n"</para>
                <para>     "}");</para>
                <para> program.link();</para>
                <para> program.bind();</para>
                <para>
                </para>
                <para> int vertexLocation = program.attributeLocation("vertex");</para>
                <para> int matrixLocation = program.uniformLocation("matrix");</para>
                <para> int colorLocation = program.uniformLocation("color");</para>
                <para>With the above shader program active, we can draw a green triangle as follows:</para>
                <para> static GLfloat const triangleVertices[] = {</para>
                <para>     60.0f,  10.0f,  0.0f,</para>
                <para>     110.0f, 110.0f, 0.0f,</para>
                <para>     10.0f,  110.0f, 0.0f</para>
                <para> };</para>
                <para>
                </para>
                <para> QColor color(0, 255, 0, 255);</para>
                <para>
                </para>
                <para> QMatrix4x4 pmvMatrix;</para>
                <para> pmvMatrix.ortho(rect());</para>
                <para>
                </para>
                <para> program.enableAttributeArray(vertexLocation);</para>
                <para> program.setAttributeArray(vertexLocation, triangleVertices, 3);</para>
                <para> program.setUniformValue(matrixLocation, pmvMatrix);</para>
                <para> program.setUniformValue(colorLocation, color);</para>
                <para>
                </para>
                <para> glDrawArrays(GL_TRIANGLES, 0, 3);</para>
                <para>
                </para>
                <para> program.disableAttributeArray(vertexLocation);</para>
                <para>
                </para>
                <para>Binary shaders and programs</para>
                <para>Binary shaders may be specified using glShaderBinary() on the return value from QGLShader::shaderId(). The QGLShader instance containing the binary can then be added to the shader program with addShader() and linked in the usual fashion with link().</para>
                <para>Binary programs may be specified using glProgramBinaryOES() on the return value from programId(). Then the application should call link(), which will notice that the program has already been specified and linked, allowing other operations to be performed on the shader program.</para>
                <para>
                </para>
                <para>See also QGLShader.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a new shader program and attaches it to parent. The program will be invalid until addShader() is called.</para>
                <para>The shader program will be associated with the current QGLContext.</para>
                <para>See also addShader().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.#ctor(QtOpenGL.QGLContext,QtCore.QObject)">
            <summary>
                <para>Constructs a new shader program and attaches it to parent. The program will be invalid until addShader() is called.</para>
                <para>The shader program will be associated with context.</para>
                <para>See also addShader().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.GeometryInputType">
            <summary>
                <para>Returns the geometry shader input type, if active.</para>
                <para>This parameter takes effect the next time the program is linked.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>Sets the input type from inputType.</para>
                <para>This parameter takes effect the next time the program is linked.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.GeometryOutputType">
            <summary>
                <para>Returns the geometry shader output type, if active.</para>
                <para>This parameter takes effect the next time the program is linked.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>Sets the output type from the geometry shader, if active, to outputType.</para>
                <para>This parameter takes effect the next time the program is linked.</para>
                <para>This function was introduced in Qt 4.7.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.GeometryOutputVertexCount">
            <summary>
                <para>Returns the maximum number of vertices the current geometry shader program will produce, if active.</para>
                <para>This parameter takes effect the ntext time the program is linked.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>Sets the maximum number of vertices the current geometry shader program will produce, if active, to count.</para>
                <para>This parameter takes effect the next time the program is linked.</para>
                <para>This function was introduced in Qt 4.7.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.IsLinked">
            <summary>
                <para>Returns true if this shader program has been linked; false otherwise.</para>
                <para>See also link().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.Link">
            <summary>
                <para>Links together the shaders that were added to this program with addShader(). Returns true if the link was successful or false otherwise. If the link failed, the error messages can be retrieved with log().</para>
                <para>Subclasses can override this function to initialize attributes and uniform variables for use in specific shader programs.</para>
                <para>If the shader program was already linked, calling this function again will force it to be re-linked.</para>
                <para>See also addShader() and log().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.Log">
            <summary>
                <para>Returns the errors and warnings that occurred during the last link() or addShader() with explicitly specified source code.</para>
                <para>See also link().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.MaxGeometryOutputVertices">
            <summary>
                <para>Returns the hardware limit for how many vertices a geometry shader can output.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also setGeometryOutputVertexCount().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.ProgramId">
            <summary>
                <para>Returns the OpenGL identifier associated with this shader program.</para>
                <para>See also QGLShader::shaderId().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.Shaders">
            <summary>
                <para>Returns a list of all shaders that have been added to this shader program using addShader().</para>
                <para>See also addShader() and removeShader().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShader(QtOpenGL.QGLShader)">
            <summary>
                <para>Adds a compiled shader to this shader program. Returns true if the shader could be added, or false otherwise.</para>
                <para>Ownership of the shader object remains with the caller. It will not be deleted when this QGLShaderProgram instance is deleted. This allows the caller to add the same shader to multiple shader programs.</para>
                <para>See also addShaderFromSourceCode(), addShaderFromSourceFile(), removeShader(), link(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShaderFromSourceCode(QtOpenGL.QGLShader.ShaderTypeBit,QtCore.QByteArray)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Compiles source as a shader of the specified type and adds it to this shader program. Returns true if compilation was successful, false otherwise. The compilation errors and warnings will be made available via log().</para>
                <para>This function is intended to be a short-cut for quickly adding vertex and fragment shaders to a shader program without creating an instance of QGLShader first.</para>
                <para>See also addShader(), addShaderFromSourceFile(), removeShader(), link(), log(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShaderFromSourceCode(QtOpenGL.QGLShader.ShaderTypeBit,System.String)">
            <summary>
                <para>Compiles source as a shader of the specified type and adds it to this shader program. Returns true if compilation was successful, false otherwise. The compilation errors and warnings will be made available via log().</para>
                <para>This function is intended to be a short-cut for quickly adding vertex and fragment shaders to a shader program without creating an instance of QGLShader first.</para>
                <para>See also addShader(), addShaderFromSourceFile(), removeShader(), link(), log(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShaderFromSourceFile(QtOpenGL.QGLShader.ShaderTypeBit,System.String)">
            <summary>
                <para>Compiles the contents of fileName as a shader of the specified type and adds it to this shader program. Returns true if compilation was successful, false otherwise. The compilation errors and warnings will be made available via log().</para>
                <para>This function is intended to be a short-cut for quickly adding vertex and fragment shaders to a shader program without creating an instance of QGLShader first.</para>
                <para>See also addShader() and addShaderFromSourceCode().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AttributeLocation(QtCore.QByteArray)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Returns the location of the attribute name within this shader program's parameter list. Returns -1 if name is not a valid attribute for this shader program.</para>
                <para>See also uniformLocation() and bindAttributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AttributeLocation(System.String)">
            <summary>
                <para>Returns the location of the attribute name within this shader program's parameter list. Returns -1 if name is not a valid attribute for this shader program.</para>
                <para>See also uniformLocation() and bindAttributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.Bind">
            <summary>
                <para>Binds this shader program to the active QGLContext and makes it the current shader program. Any previously bound shader program is released. This is equivalent to calling glUseProgram() on programId(). Returns true if the program was successfully bound; false otherwise. If the shader program has not yet been linked, or it needs to be re-linked, this function will call link().</para>
                <para>See also link() and release().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.BindAttributeLocation(QtCore.QByteArray,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Binds the attribute name to the specified location. This function can be called before or after the program has been linked. Any attributes that have not been explicitly bound when the program is linked will be assigned locations automatically.</para>
                <para>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</para>
                <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.BindAttributeLocation(System.String,System.Int32)">
            <summary>
                <para>Binds the attribute name to the specified location. This function can be called before or after the program has been linked. Any attributes that have not been explicitly bound when the program is linked will be assigned locations automatically.</para>
                <para>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</para>
                <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.DisableAttributeArray(System.Int32)">
            <summary>
                <para>Disables the vertex array at location in this shader program that was enabled by a previous call to enableAttributeArray().</para>
                <para>See also enableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.DisableAttributeArray(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Disables the vertex array called name in this shader program that was enabled by a previous call to enableAttributeArray().</para>
                <para>See also enableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.EnableAttributeArray(System.Int32)">
            <summary>
                <para>Enables the vertex array at location in this shader program so that the value set by setAttributeArray() on location will be used by the shader program.</para>
                <para>See also disableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.EnableAttributeArray(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Enables the vertex array called name in this shader program so that the value set by setAttributeArray() on name will be used by the shader program.</para>
                <para>See also disableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.HasOpenGLShaderPrograms(QtOpenGL.QGLContext)">
            <summary>
                <para>Returns true if shader programs written in the OpenGL Shading Language (GLSL) are supported on this system; false otherwise.</para>
                <para>The context is used to resolve the GLSL extensions. If context is null, then QGLContext::currentContext() is used.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.Release">
            <summary>
                <para>Releases the active shader program from the current QGLContext. This is equivalent to calling glUseProgram(0).</para>
                <para>See also bind().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.RemoveAllShaders">
            <summary>
                <para>Removes all of the shaders that were added to this program previously. The QGLShader objects for the shaders will not be deleted if they were constructed externally. QGLShader objects that are constructed internally by QGLShaderProgram will be deleted.</para>
                <para>See also addShader() and removeShader().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.RemoveShader(QtOpenGL.QGLShader)">
            <summary>
                <para>Removes shader from this shader program. The object is not deleted.</para>
                <para>See also addShader(), link(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,QtGui.QVector2D,System.Int32)">
            <summary>
                <para>Sets an array of 2D vertex values on the attribute at location in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,QtGui.QVector3D,System.Int32)">
            <summary>
                <para>Sets an array of 3D vertex values on the attribute at location in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,QtGui.QVector4D,System.Int32)">
            <summary>
                <para>Sets an array of 4D vertex values on the attribute at location in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,QtGui.QVector2D,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets an array of 2D vertex values on the attribute called name in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,QtGui.QVector3D,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets an array of 3D vertex values on the attribute called name in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,QtGui.QVector4D,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets an array of 4D vertex values on the attribute called name in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,System.Single,System.Int32,System.Int32)">
            <summary>
                <para>Sets an array of vertex values on the attribute at location in this shader program. The tupleSize indicates the number of components per vertex (1, 2, 3, or 4), and the stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,System.Single,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets an array of vertex values on the attribute called name in this shader program. The tupleSize indicates the number of components per vertex (1, 2, 3, or 4), and the stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
                <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
                <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeBuffer(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Sets an array of vertex values on the attribute at location in this shader program, starting at a specific offset in the currently bound vertex buffer. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in the value array.</para>
                <para>The type indicates the type of elements in the vertex value array, usually GL_FLOAT, GL_UNSIGNED_BYTE, etc. The tupleSize indicates the number of components per vertex: 1, 2, 3, or 4.</para>
                <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also setAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeBuffer(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets an array of vertex values on the attribute called name in this shader program, starting at a specific offset in the currently bound vertex buffer. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in the value array.</para>
                <para>The type indicates the type of elements in the vertex value array, usually GL_FLOAT, GL_UNSIGNED_BYTE, etc. The tupleSize indicates the number of components per vertex: 1, 2, 3, or 4.</para>
                <para>The array will become active when enableAttributeArray() is called on the name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
                <para>This function was introduced in Qt 4.7.</para>
                <para>See also setAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QVector2D)">
            <summary>
                <para>Sets the attribute at location in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QVector3D)">
            <summary>
                <para>Sets the attribute at location in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QVector4D)">
            <summary>
                <para>Sets the attribute at location in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QColor)">
            <summary>
                <para>Sets the attribute at location in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QVector2D)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QVector3D)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QVector4D)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QColor)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single)">
            <summary>
                <para>Sets the attribute at location in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to value.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single,System.Int32,System.Int32)">
            <summary>
                <para>Sets the attribute at location in the current context to the contents of values, which contains columns elements, each consisting of rows elements. The rows value should be 1, 2, 3, or 4. This function is typically used to set matrix values and column vectors.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to the contents of values, which contains columns elements, each consisting of rows elements. The rows value should be 1, 2, 3, or 4. This function is typically used to set matrix values and column vectors.</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single,System.Single)">
            <summary>
                <para>Sets the attribute at location in the current context to the 2D vector (x, y).</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to the 2D vector (x, y).</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
                <para>Sets the attribute at location in the current context to the 3D vector (x, y, z).</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single,System.Single,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to the 3D vector (x, y, z).</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                <para>Sets the attribute at location in the current context to the 4D vector (x, y, z, w).</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the attribute called name in the current context to the 4D vector (x, y, z, w).</para>
                <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QVector2D)">
            <summary>
                <para>Sets the uniform variable at location in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QVector3D)">
            <summary>
                <para>Sets the uniform variable at location in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QVector4D)">
            <summary>
                <para>Sets the uniform variable at location in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QColor)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the red, green, blue, and alpha components of color.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QPoint)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the x and y coordinates of point.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QPointF)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the x and y coordinates of point.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QSize)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the width and height of the given size.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QSizeF)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the width and height of the given size.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QMatrix4x4)">
            <summary>
                <para>Sets the uniform variable at location in the current context to a 4x4 matrix value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QTransform)">
            <summary>
                <para>Sets the uniform variable at location in the current context to a 3x3 transformation matrix value that is specified as a QTransform value.</para>
                <para>To set a QTransform value as a 4x4 matrix in a shader, use setUniformValue(location, QMatrix4x4(value)).</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QVector2D)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QVector3D)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QVector4D)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QColor)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to the red, green, blue, and alpha components of color.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QPoint)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable associated with name in the current context to the x and y coordinates of point.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QPointF)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable associated with name in the current context to the x and y coordinates of point.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QSize)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable associated with name in the current context to the width and height of the given size.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QSizeF)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable associated with name in the current context to the width and height of the given size.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QMatrix4x4)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to a 4x4 matrix value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QTransform)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to a 3x3 transformation matrix value that is specified as a QTransform value.</para>
                <para>To set a QTransform value as a 4x4 matrix in a shader, use setUniformValue(name, QMatrix4x4(value)).</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single)">
            <summary>
                <para>Sets the uniform variable at location in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Int32)">
            <summary>
                <para>Sets the uniform variable at location in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.UInt32)">
            <summary>
                <para>Sets the uniform variable at location in the current context to value. This function should be used when setting sampler values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to value.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.UInt32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to value. This function should be used when setting sampler values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single,System.Single)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the 2D vector (x, y).</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to the 2D vector (x, y).</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the 3D vector (x, y, z).</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single,System.Single,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to the 3D vector (x, y, z).</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                <para>Sets the uniform variable at location in the current context to the 4D vector (x, y, z, w).</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable called name in the current context to the 4D vector (x, y, z, w).</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QVector2D,System.Int32)">
            <summary>
                <para>Sets the uniform variable array at location in the current context to the count 2D vector elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QVector3D,System.Int32)">
            <summary>
                <para>Sets the uniform variable array at location in the current context to the count 3D vector elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QVector4D,System.Int32)">
            <summary>
                <para>Sets the uniform variable array at location in the current context to the count 4D vector elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QMatrix4x4,System.Int32)">
            <summary>
                <para>Sets the uniform variable array at location in the current context to the count 4x4 matrix elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QVector2D,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable array called name in the current context to the count 2D vector elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QVector3D,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable array called name in the current context to the count 3D vector elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QVector4D,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable array called name in the current context to the count 4D vector elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QMatrix4x4,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable array called name in the current context to the count 4x4 matrix elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,System.Int32,System.Int32)">
            <summary>
                <para>Sets the uniform variable array at location in the current context to the count elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,System.UInt32,System.Int32)">
            <summary>
                <para>Sets the uniform variable array at location in the current context to the count elements of values. This overload should be used when setting an array of sampler values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable array called name in the current context to the count elements of values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,System.UInt32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable array called name in the current context to the count elements of values. This overload should be used when setting an array of sampler values.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,System.Single,System.Int32,System.Int32)">
            <summary>
                <para>Sets the uniform variable array at location in the current context to the count elements of values. Each element has tupleSize components. The tupleSize must be 1, 2, 3, or 4.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,System.Single,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the uniform variable array called name in the current context to the count elements of values. Each element has tupleSize components. The tupleSize must be 1, 2, 3, or 4.</para>
                <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.UniformLocation(QtCore.QByteArray)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Returns the location of the uniform variable name within this shader program's parameter list. Returns -1 if name is not a valid uniform variable for this shader program.</para>
                <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.UniformLocation(System.String)">
            <summary>
                <para>Returns the location of the uniform variable name within this shader program's parameter list. Returns -1 if name is not a valid uniform variable for this shader program.</para>
                <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.Finalize">
            <summary>
                <para>Deletes this shader program.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLWidget">
            <summary>
            The QGLWidget class is a widget for rendering OpenGL graphics.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QGLWidget provides functionality for displaying OpenGL graphics integrated into a Qt application. It is very simple to use. You inherit from it and use the subclass like any other QWidget, except that you have the choice between using QPainter and standard OpenGL rendering commands.</para>
                <para>QGLWidget provides three convenient virtual functions that you can reimplement in your subclass to perform the typical OpenGL tasks:</para>
                <para>
                </para>
                <para>paintGL() - Renders the OpenGL scene. Gets called whenever the widget needs to be updated.</para>
                <para>resizeGL() - Sets up the OpenGL viewport, projection, etc. Gets called whenever the widget has been resized (and also when it is shown for the first time because all newly created widgets get a resize event automatically).</para>
                <para>initializeGL() - Sets up the OpenGL rendering context, defines display lists, etc. Gets called once before the first time resizeGL() or paintGL() is called.</para>
                <para>
                </para>
                <para>Here is a rough outline of how a QGLWidget subclass might look:</para>
                <para> class MyGLDrawer : public QGLWidget</para>
                <para> {</para>
                <para>     Q_OBJECT        // must include this if you use Qt signals/slots</para>
                <para>
                </para>
                <para> public:</para>
                <para>     MyGLDrawer(QWidget *parent)</para>
                <para>         : QGLWidget(parent) {}</para>
                <para>
                </para>
                <para> protected:</para>
                <para>
                </para>
                <para>     void initializeGL()</para>
                <para>     {</para>
                <para>         // Set up the rendering context, define display lists etc.:</para>
                <para>         ...</para>
                <para>         glClearColor(0.0, 0.0, 0.0, 0.0);</para>
                <para>         glEnable(GL_DEPTH_TEST);</para>
                <para>         ...</para>
                <para>     }</para>
                <para>
                </para>
                <para>     void resizeGL(int w, int h)</para>
                <para>     {</para>
                <para>         // setup viewport, projection etc.:</para>
                <para>         glViewport(0, 0, (GLint)w, (GLint)h);</para>
                <para>         ...</para>
                <para>         glFrustum(...);</para>
                <para>         ...</para>
                <para>     }</para>
                <para>
                </para>
                <para>     void paintGL()</para>
                <para>     {</para>
                <para>         // draw the scene:</para>
                <para>         ...</para>
                <para>         glRotatef(...);</para>
                <para>         glMaterialfv(...);</para>
                <para>         glBegin(GL_QUADS);</para>
                <para>         glVertex3f(...);</para>
                <para>         glVertex3f(...);</para>
                <para>         ...</para>
                <para>         glEnd();</para>
                <para>         ...</para>
                <para>     }</para>
                <para>
                </para>
                <para> };</para>
                <para>If you need to trigger a repaint from places other than paintGL() (a typical example is when using timers to animate scenes), you should call the widget's updateGL() function.</para>
                <para>Your widget's OpenGL rendering context is made current when paintGL(), resizeGL(), or initializeGL() is called. If you need to call the standard OpenGL API functions from other places (e.g. in your widget's constructor or in your own paint functions), you must call makeCurrent() first.</para>
                <para>QGLWidget provides functions for requesting a new display format and you can also create widgets with customized rendering contexts.</para>
                <para>You can also share OpenGL display lists between QGLWidget objects (see the documentation of the QGLWidget constructors for details).</para>
                <para>Note that under Windows, the QGLContext belonging to a QGLWidget has to be recreated when the QGLWidget is reparented. This is necessary due to limitations on the Windows platform. This will most likely cause problems for users that have subclassed and installed their own QGLContext on a QGLWidget. It is possible to work around this issue by putting the QGLWidget inside a dummy widget and then reparenting the dummy widget, instead of the QGLWidget. This will side-step the issue altogether, and is what we recommend for users that need this kind of functionality.</para>
                <para>On Mac OS X, when Qt is built with Cocoa support, a QGLWidget can't have any sibling widgets placed ontop of itself. This is due to limitations in the Cocoa API and is not supported by Apple.</para>
                <para>
                </para>
                <para>Overlays</para>
                <para>The QGLWidget creates a GL overlay context in addition to the normal context if overlays are supported by the underlying system.</para>
                <para>If you want to use overlays, you specify it in the format. (Note: Overlay must be requested in the format passed to the QGLWidget constructor.) Your GL widget should also implement some or all of these virtual methods:</para>
                <para>
                </para>
                <para>paintOverlayGL()</para>
                <para>resizeOverlayGL()</para>
                <para>initializeOverlayGL()</para>
                <para>
                </para>
                <para>These methods work in the same way as the normal paintGL() etc. functions, except that they will be called when the overlay context is made current. You can explicitly make the overlay context current by using makeOverlayCurrent(), and you can access the overlay context directly (e.g. to ask for its transparent color) by calling overlayContext().</para>
                <para>On X servers in which the default visual is in an overlay plane, non-GL Qt windows can also be used for overlays.</para>
                <para>
                </para>
                <para>Painting Techniques</para>
                <para>As described above, subclass QGLWidget to render pure 3D content in the following way:</para>
                <para>
                </para>
                <para>Reimplement the QGLWidget::initializeGL() and QGLWidget::resizeGL() to set up the OpenGL state and provide a perspective transformation.</para>
                <para>Reimplement QGLWidget::paintGL() to paint the 3D scene, calling only OpenGL functions to draw on the widget.</para>
                <para>
                </para>
                <para>It is also possible to draw 2D graphics onto a QGLWidget subclass, it is necessary to reimplement QGLWidget::paintEvent() and do the following:</para>
                <para>
                </para>
                <para>Construct a QPainter object.</para>
                <para>Initialize it for use on the widget with the QPainter::begin() function.</para>
                <para>Draw primitives using QPainter's member functions.</para>
                <para>Call QPainter::end() to finish painting.</para>
                <para>
                </para>
                <para>Overpainting 2D content on top of 3D content takes a little more effort. One approach to doing this is shown in the Overpainting example.</para>
                <para>
                </para>
                <para>Threading</para>
                <para>As of Qt version 4.8, support for doing threaded GL rendering has been improved. There are three scenarios that we currently support:</para>
                <para>
                </para>
                <para>1. Buffer swapping in a thread.Swapping buffers in a double buffered context may be a synchronous, locking call that may be a costly operation in some GL implementations. Especially so on embedded devices. It's not optimal to have the CPU idling while the GPU is doing a buffer swap. In those cases it is possible to do the rendering in the main thread and do the actual buffer swap in a separate thread. This can be done with the following steps:</para>
                <para>1. Call doneCurrent() in the main thread when the rendering is finished.</para>
                <para>2. Notify the swapping thread that it can grab the context.</para>
                <para>3. Make the rendering context current in the swapping thread with makeCurrent() and then call swapBuffers().</para>
                <para>4. Call doneCurrent() in the swapping thread and notify the main thread that swapping is done.</para>
                <para>Doing this will free up the main thread so that it can continue with, for example, handling UI events or network requests. Even if there is a context swap involved, it may be preferable compared to having the main thread wait while the GPU finishes the swap operation. Note that this is highly implementation dependent.</para>
                <para>
                </para>
                <para>2. Texture uploading in a thread.Doing texture uploads in a thread may be very useful for applications handling large amounts of images that needs to be displayed, like for instance a photo gallery application. This is supported in Qt through the existing bindTexture() API. A simple way of doing this is to create two sharing QGLWidgets. One is made current in the main GUI thread, while the other is made current in the texture upload thread. The widget in the uploading thread is never shown, it is only used for sharing textures with the main thread. For each texture that is bound via bindTexture(), notify the main thread so that it can start using the texture.</para>
                <para>
                </para>
                <para>3. Using QPainter to draw into a QGLWidget in a thread.In Qt 4.8, it is possible to draw into a QGLWidget using a QPainter in a separate thread. Note that this is also possible for QGLPixelBuffers and QGLFramebufferObjects. Since this is only supported in the GL 2 paint engine, OpenGL 2.0 or OpenGL ES 2.0 is required.</para>
                <para>QGLWidgets can only be created in the main GUI thread. This means a call to doneCurrent() is necessary to release the GL context from the main thread, before the widget can be drawn into by another thread. Also, the main GUI thread will dispatch resize and paint events to a QGLWidget when the widget is resized, or parts of it becomes exposed or needs redrawing. It is therefore necessary to handle those events because the default implementations inside QGLWidget will try to make the QGLWidget's context current, which again will interfere with any threads rendering into the widget. Reimplement QGLWidget::paintEvent() and QGLWidget::resizeEvent() to notify the rendering thread that a resize or update is necessary, and be careful not to call the base class implementation. If you are rendering an animation, it might not be necessary to handle the paint event at all since the rendering thread is doing regular updates. Then it would be enough to reimplement QGLWidget::paintEvent() to do nothing.</para>
                <para>
                </para>
                <para>
                </para>
                <para>As a general rule when doing threaded rendering: be aware that binding and releasing contexts in different threads have to be synchronized by the user. A GL rendering context can only be current in one thread at any time. If you try to open a QPainter on a QGLWidget and the widget's rendering context is current in another thread, it will fail.</para>
                <para>Note that under X11 it is necessary to set the Qt::AA_X11InitThreads application attribute to make the X11 library and GLX calls thread safe, otherwise the above scenarios will fail.</para>
                <para>In addition to this, rendering using raw GL calls in a separate thread is supported.</para>
                <para>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</para>
                <para>
                </para>
                <para>See also QGLPixelBuffer, Hello GL Example, 2D Painting Example, Overpainting Example, and Grabber Example.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLWidget.#ctor(QtOpenGL.QGLContext,QtGui.QWidget,QtOpenGL.QGLWidget,QtCore.Qt.WindowType)">
            <summary>
                <para>Constructs an OpenGL widget with parent parent.</para>
                <para>The context argument is a pointer to the QGLContext that you wish to be bound to this widget. This allows you to pass in your own QGLContext sub-classes.</para>
                <para>The widget will be invalid if the system has no OpenGL support.</para>
                <para>The parent and widget flag, f, arguments are passed to the QWidget constructor.</para>
                <para>If shareWidget is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with shareWidget. But if shareWidget and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</para>
                <para>The initialization of OpenGL rendering state, etc. should be done by overriding the initializeGL() function, rather than in the constructor of your QGLWidget subclass.</para>
                <para>See also QGLFormat::defaultFormat() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.#ctor(QtOpenGL.QGLFormat,QtGui.QWidget,QtOpenGL.QGLWidget,QtCore.Qt.WindowType)">
            <summary>
                <para>Constructs an OpenGL widget with parent parent.</para>
                <para>The format argument specifies the desired rendering options. If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</para>
                <para>The widget will be invalid if the system has no OpenGL support.</para>
                <para>The parent and widget flag, f, arguments are passed to the QWidget constructor.</para>
                <para>If shareWidget is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with shareWidget. But if shareWidget and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</para>
                <para>The initialization of OpenGL rendering state, etc. should be done by overriding the initializeGL() function, rather than in the constructor of your QGLWidget subclass.</para>
                <para>See also QGLFormat::defaultFormat() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.#ctor(QtGui.QWidget,QtOpenGL.QGLWidget,QtCore.Qt.WindowType)">
            <summary>
                <para>Constructs an OpenGL widget with a parent widget.</para>
                <para>The default format is used. The widget will be invalid if the system has no OpenGL support.</para>
                <para>The parent and widget flag, f, arguments are passed to the QWidget constructor.</para>
                <para>If shareWidget is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with shareWidget. But if shareWidget and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</para>
                <para>The initialization of OpenGL rendering state, etc. should be done by overriding the initializeGL() function, rather than in the constructor of your QGLWidget subclass.</para>
                <para>See also QGLFormat::defaultFormat() and Textures Example.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.AutoBufferSwap">
            <summary>
                <para>Returns true if the widget is doing automatic GL buffer swapping; otherwise returns false.</para>
                <para>If on is true automatic GL buffer swapping is switched on; otherwise it is switched off.</para>
                <para>If on is true and the widget is using a double-buffered format, the background and foreground GL buffers will automatically be swapped after each paintGL() call.</para>
                <para>The buffer auto-swapping is on by default.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.Colormap">
            <summary>
                <para>Returns the colormap for this widget.</para>
                <para>Usually it is only top-level widgets that can have different colormaps installed. Asking for the colormap of a child widget will return the colormap for the child's top-level widget.</para>
                <para>If no colormap has been set for this widget, the QGLColormap returned will be empty.</para>
                <para>Set the colormap for this widget to cmap. Usually it is only top-level widgets that can have colormaps installed.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.Format">
            <summary>
                <para>Returns the format of the contained GL rendering context.</para>
                <para>Sets a new format for this widget.</para>
                <para>If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual rendering context format obtained.</para>
                <para>The widget will be assigned a new QGLContext, and the initializeGL() function will be executed for this new context before the first resizeGL() or paintGL().</para>
                <para>This method will try to keep display list and texture object sharing in effect with other QGLWidget objects, but changing the format might make sharing impossible. Use isSharing() to see if sharing is still in effect.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.Context">
            <summary>
                <para>Returns the context of this widget.</para>
                <para>It is possible that the context is not valid (see isValid()), for example, if the underlying hardware does not support the format attributes that were requested.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.DoubleBuffer">
            <summary>
                <para>Returns true if the contained GL rendering context has double buffering; otherwise returns false.</para>
                <para>See also QGLFormat::doubleBuffer().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.IsSharing">
            <summary>
                <para>Returns true if this widget's GL context is shared with another GL context, otherwise false is returned. Context sharing might not be possible if the widgets use different formats.</para>
                <para>See also format().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.IsValid">
            <summary>
                <para>Returns true if the widget has a valid GL rendering context; otherwise returns false. A widget will be invalid if the system has no OpenGL support.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.OverlayContext">
            <summary>
                <para>Returns the overlay context of this widget, or 0 if this widget has no overlay.</para>
                <para>See also context().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QImage)">
            <summary>
                <para>Calls QGLContext:::bindTexture(image, target, format) on the currently set context.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QPixmap)">
            <summary>
                <para>Calls QGLContext:::bindTexture(pixmap, target, format) on the currently set context.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QImage,System.Int32)">
            <summary>
                <para>Calls QGLContext:::bindTexture(image, target, format) on the currently set context.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QPixmap,System.Int32)">
            <summary>
                <para>Calls QGLContext:::bindTexture(pixmap, target, format) on the currently set context.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QImage,System.Int32,System.Int32)">
            <summary>
                <para>Calls QGLContext:::bindTexture(image, target, format) on the currently set context.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QPixmap,System.Int32,System.Int32)">
            <summary>
                <para>Calls QGLContext:::bindTexture(pixmap, target, format) on the currently set context.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QImage,System.Int32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>The binding options are a set of options used to decide how to bind the texture to the context.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QPixmap,System.Int32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Generates and binds a 2D GL texture to the current context, based on pixmap. The generated texture id is returned and can be used in</para>
                <para>The binding options are a set of options used to decide how to bind the texture to the context.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Calls QGLContext::bindTexture(fileName) on the currently set context.</para>
                <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.ConvertToGLFormat(QtGui.QImage)">
            <summary>
                <para>Converts the image img into the unnamed format expected by OpenGL functions such as glTexImage2D(). The returned image is not usable as a QImage, but QImage::width(), QImage::height() and QImage::bits() may be used with OpenGL. The GL format used is GL_RGBA.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DeleteTexture(System.UInt32)">
            <summary>
                <para>Calls QGLContext::deleteTexture(id) on the currently set context.</para>
                <para>See also bindTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DoneCurrent">
            <summary>
                <para>Makes no GL context the current context. Normally, you do not need to call this function; QGLContext calls it as necessary. However, it may be useful in multithreaded environments.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DrawTexture(QtCore.QRectF,System.UInt32)">
            <summary>
                <para>Calls the corresponding QGLContext::drawTexture() with target, textureId, and textureTarget for this widget's context.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DrawTexture(QtCore.QPointF,System.UInt32)">
            <summary>
                <para>Calls the corresponding QGLContext::drawTexture() with point, textureId, and textureTarget for this widget's context.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DrawTexture(QtCore.QRectF,System.UInt32,System.Int32)">
            <summary>
                <para>Calls the corresponding QGLContext::drawTexture() with target, textureId, and textureTarget for this widget's context.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DrawTexture(QtCore.QPointF,System.UInt32,System.Int32)">
            <summary>
                <para>Calls the corresponding QGLContext::drawTexture() with point, textureId, and textureTarget for this widget's context.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.OnEvent(QtCore.QEvent)">
            <summary>
                <para>Reimplemented from QObject::event().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.FontDisplayListBase(QtGui.QFont,System.Int32)">
            <summary>
                <para>Returns the value of the first display list that is generated for the characters in the given font. listBase indicates the base value used when generating the display lists for the font. The default value is 2000.</para>
                <para>Note: This function is not supported on OpenGL/ES systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.GlDraw">
            <summary>
                <para>Executes the virtual function paintGL().</para>
                <para>The widget's rendering context will become the current context and initializeGL() will be called if it hasn't already been called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.GlInit">
            <summary>
                <para>Initializes OpenGL for this widget's context. Calls the virtual function initializeGL().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.GrabFrameBuffer(System.Boolean)">
            <summary>
                <para>Returns an image of the frame buffer. If withAlpha is true the alpha channel is included.</para>
                <para>Depending on your hardware, you can explicitly select which color buffer to grab with a glReadBuffer() call before calling this function.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.InitializeGL">
            <summary>
                <para>This virtual function is called once before the first call to paintGL() or resizeGL(), and then once whenever the widget has been assigned a new QGLContext. Reimplement it in a subclass.</para>
                <para>This function should set up any required OpenGL context rendering flags, defining display lists, etc.</para>
                <para>There is no need to call makeCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.InitializeOverlayGL">
            <summary>
                <para>This virtual function is used in the same manner as initializeGL() except that it operates on the widget's overlay context instead of the widget's main context. This means that initializeOverlayGL() is called once before the first call to paintOverlayGL() or resizeOverlayGL(). Reimplement it in a subclass.</para>
                <para>This function should set up any required OpenGL context rendering flags, defining display lists, etc. for the overlay context.</para>
                <para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.MakeCurrent">
            <summary>
                <para>Makes this widget the current widget for OpenGL operations, i.e. makes the widget's rendering context the current OpenGL rendering context.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.MakeOverlayCurrent">
            <summary>
                <para>Makes the overlay context of this widget current. Use this if you need to issue OpenGL commands to the overlay context outside of initializeOverlayGL(), resizeOverlayGL(), and paintOverlayGL().</para>
                <para>Does nothing if this widget has no overlay.</para>
                <para>See also makeCurrent().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.OnPaintEvent(QtGui.QPaintEvent)">
            <summary>
                <para>Reimplemented from QWidget::paintEvent().</para>
                <para>Handles paint events passed in the event parameter. Will cause the virtual paintGL() function to be called.</para>
                <para>The widget's rendering context will become the current context and initializeGL() will be called if it hasn't already been called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.PaintGL">
            <summary>
                <para>This virtual function is called whenever the widget needs to be painted. Reimplement it in a subclass.</para>
                <para>There is no need to call makeCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.PaintOverlayGL">
            <summary>
                <para>This virtual function is used in the same manner as paintGL() except that it operates on the widget's overlay context instead of the widget's main context. This means that paintOverlayGL() is called whenever the widget's overlay needs to be painted. Reimplement it in a subclass.</para>
                <para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.QglClearColor(QtGui.QColor)">
            <summary>
                <para>Convenience function for specifying the clearing color to OpenGL. Calls glClearColor (in RGBA mode) or glClearIndex (in color-index mode) with the color c. Applies to this widgets GL context.</para>
                <para>See also qglColor(), QGLContext::currentContext(), and QColor.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.QglColor(QtGui.QColor)">
            <summary>
                <para>Convenience function for specifying a drawing color to OpenGL. Calls glColor4 (in RGBA mode) or glIndex (in color-index mode) with the color c. Applies to this widgets GL context.</para>
                <para>Note: This function is not supported on OpenGL/ES 2.0 systems.</para>
                <para>See also qglClearColor(), QGLContext::currentContext(), and QColor.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderPixmap(System.Int32,System.Int32,System.Boolean)">
            <summary>
                <para>Renders the current scene on a pixmap and returns the pixmap.</para>
                <para>You can use this method on both visible and invisible QGLWidget objects.</para>
                <para>This method will create a pixmap and a temporary QGLContext to render on the pixmap. It will then call initializeGL(), resizeGL(), and paintGL() on this context. Finally, the widget's original GL context is restored.</para>
                <para>The size of the pixmap will be w pixels wide and h pixels high unless one of these parameters is 0 (the default), in which case the pixmap will have the same size as the widget.</para>
                <para>If useContext is true, this method will try to be more efficient by using the existing GL context to render the pixmap. The default is false. Only use true if you understand the risks. Note that under Windows a temporary context has to be created and usage of the useContext parameter is not supported.</para>
                <para>Overlays are not rendered onto the pixmap.</para>
                <para>If the GL rendering context and the desktop have different bit depths, the result will most likely look surprising.</para>
                <para>Note that the creation of display lists, modifications of the view frustum etc. should be done from within initializeGL(). If this is not done, the temporary QGLContext will not be initialized properly, and the rendered pixmap may be incomplete/corrupted.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Int32,System.Int32,System.String)">
            <summary>
                <para>Renders the string str into the GL context of this widget.</para>
                <para>x and y are specified in window coordinates, with the origin in the upper left-hand corner of the window. If font is not specified, the currently set application font will be used to render the string. To change the color of the rendered text you can use the glColor() call (or the qglColor() convenience function), just before the renderText() call.</para>
                <para>The listBase parameter is obsolete and will be removed in a future version of Qt.</para>
                <para>Note: This function clears the stencil buffer.</para>
                <para>Note: This function is not supported on OpenGL/ES systems.</para>
                <para>Note: This function temporarily disables depth-testing when the text is drawn.</para>
                <para>Note: This function can only be used inside a QPainter::beginNativePainting()/QPainter::endNativePainting() block if the default OpenGL paint engine is QPaintEngine::OpenGL. To make QPaintEngine::OpenGL the default GL engine, call QGL::setPreferredPaintEngine(QPaintEngine::OpenGL) before the QApplication constructor.</para>
                <para>Overpaint with QPainter::drawText() instead.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Int32,System.Int32,System.String,QtGui.QFont,System.Int32)">
            <summary>
                <para>Renders the string str into the GL context of this widget.</para>
                <para>x and y are specified in window coordinates, with the origin in the upper left-hand corner of the window. If font is not specified, the currently set application font will be used to render the string. To change the color of the rendered text you can use the glColor() call (or the qglColor() convenience function), just before the renderText() call.</para>
                <para>The listBase parameter is obsolete and will be removed in a future version of Qt.</para>
                <para>Note: This function clears the stencil buffer.</para>
                <para>Note: This function is not supported on OpenGL/ES systems.</para>
                <para>Note: This function temporarily disables depth-testing when the text is drawn.</para>
                <para>Note: This function can only be used inside a QPainter::beginNativePainting()/QPainter::endNativePainting() block if the default OpenGL paint engine is QPaintEngine::OpenGL. To make QPaintEngine::OpenGL the default GL engine, call QGL::setPreferredPaintEngine(QPaintEngine::OpenGL) before the QApplication constructor.</para>
                <para>Overpaint with QPainter::drawText() instead.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Double,System.Double,System.Double,System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>x, y and z are specified in scene or object coordinates relative to the currently set projection and model matrices. This can be useful if you want to annotate models with text labels and have the labels move with the model as it is rotated etc.</para>
                <para>Note: This function is not supported on OpenGL/ES systems.</para>
                <para>Note: If depth testing is enabled before this function is called, then the drawn text will be depth-tested against the models that have already been drawn in the scene. Use glDisable(GL_DEPTH_TEST) before calling this function to annotate the models without depth-testing the text.</para>
                <para>Overpaint with QPainter::drawText() instead.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Double,System.Double,System.Double,System.String,QtGui.QFont,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>x, y and z are specified in scene or object coordinates relative to the currently set projection and model matrices. This can be useful if you want to annotate models with text labels and have the labels move with the model as it is rotated etc.</para>
                <para>Note: This function is not supported on OpenGL/ES systems.</para>
                <para>Note: If depth testing is enabled before this function is called, then the drawn text will be depth-tested against the models that have already been drawn in the scene. Use glDisable(GL_DEPTH_TEST) before calling this function to annotate the models without depth-testing the text.</para>
                <para>Overpaint with QPainter::drawText() instead.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.OnResizeEvent(QtGui.QResizeEvent)">
            <summary>
                <para>Reimplemented from QWidget::resizeEvent().</para>
                <para>Handles resize events that are passed in the event parameter. Calls the virtual function resizeGL().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.ResizeGL(System.Int32,System.Int32)">
            <summary>
                <para>This virtual function is called whenever the widget has been resized. The new size is passed in width and height. Reimplement it in a subclass.</para>
                <para>There is no need to call makeCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.ResizeOverlayGL(System.Int32,System.Int32)">
            <summary>
                <para>This virtual function is used in the same manner as paintGL() except that it operates on the widget's overlay context instead of the widget's main context. This means that resizeOverlayGL() is called whenever the widget has been resized. The new size is passed in width and height. Reimplement it in a subclass.</para>
                <para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.SetMouseTracking(System.Boolean)">
            <summary>
                <para>If enable is true then mouse tracking is enabled; otherwise it is disabled.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.SwapBuffers">
            <summary>
                <para>Swaps the screen contents with an off-screen buffer. This only works if the widget's format specifies double buffer mode.</para>
                <para>Normally, there is no need to explicitly call this function because it is done automatically after each widget repaint, i.e. each time after paintGL() has been executed.</para>
                <para>See also doubleBuffer(), setAutoBufferSwap(), and QGLFormat::setDoubleBuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.UpdateGL">
            <summary>
                <para>Updates the widget by calling glDraw().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.UpdateOverlayGL">
            <summary>
                <para>Updates the widget's overlay (if any). Will cause the virtual function paintOverlayGL() to be executed.</para>
                <para>The widget's rendering context will become the current context and initializeGL() will be called if it hasn't already been called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.Finalize">
            <summary>
                <para>Destroys the widget.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.Global.QVersion">
            <summary>
                <para>Returns the version number of Qt at run-time as a string (for example, "4.1.2"). This may be a different version than the version the application was compiled against.</para>
                <para>See also QT_VERSION_STR.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.Global.Qrand">
            <summary>
                <para>Thread-safe version of the standard C++ rand() function.</para>
                <para>Returns a value between 0 and RAND_MAX (defined in &lt;cstdlib&gt; and &lt;stdlib.h&gt;), the next number in the current sequence of pseudo-random integers.</para>
                <para>Use qsrand() to initialize the pseudo-random number generator with a seed value.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also qsrand().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.Write(QtCore.QDataStream,System.Collections.Generic.List{System.String})">
            <summary>
                <para>Writes the given string list to the specified out stream.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.Read(QtCore.QDataStream,System.Collections.Generic.List{System.String})">
            <summary>
                <para>Reads a string list from the given in stream into the specified list.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QAcos(System.Double)">
            <summary>
                <para>Returns the arccosine of v as an angle in radians. Arccosine is the inverse operation of cosine.</para>
                <para>See also qAtan(), qAsin(), and qCos().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QAsin(System.Double)">
            <summary>
                <para>Returns the arcsine of v as an angle in radians. Arcsine is the inverse operation of sine.</para>
                <para>See also qSin(), qAtan(), and qAcos().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QAtan(System.Double)">
            <summary>
                <para>Returns the arctangent of v as an angle in radians. Arctangent is the inverse operation of tangent.</para>
                <para>See also qTan(), qAcos(), and qAsin().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QAtan2(System.Double,System.Double)">
            <summary>
                <para>Returns the arctangent of a point specified by the coordinates x and y. This function will return the angle and its direction.</para>
                <para>See also qAtan().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QCeil(System.Double)">
            <summary>
                <para>Return the ceiling of the value v.</para>
                <para>The ceiling is the smallest integer that is not less than v. For example, if v is 41.2, then the ceiling is 42.</para>
                <para>See also qFloor().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QCos(System.Double)">
            <summary>
                <para>Returns the cosine of an angle v in radians.</para>
                <para>See also qSin() and qTan().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawBorderPixmap(QtGui.QPainter,QtCore.QRect,QtCore.QMargins,QtGui.QPixmap)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>The qDrawBorderPixmap function is for drawing a pixmap into the margins of a rectangle.</para>
                <para>Draws the given pixmap into the given target rectangle, using the given painter. The pixmap will be split into nine segments and drawn according to the margins structure.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawPlainRect(QtGui.QPainter,QtCore.QRect,QtGui.QColor,System.Int32,QtGui.QBrush)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Draws the plain rectangle specified by rect using the given painter, lineColor and lineWidth. The rectangle's interior is filled with the fill brush unless fill is 0.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a plain rectangle:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle(QFrame::Box | QFrame::Plain);</para>
                <para>See also qDrawShadeRect() and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawPlainRect(QtGui.QPainter,System.Int32,System.Int32,System.Int32,System.Int32,QtGui.QColor,System.Int32,QtGui.QBrush)">
            <summary>
                <para>Draws the plain rectangle beginning at (x, y) with the given width and height, using the specified painter, lineColor and lineWidth. The rectangle's interior is filled with the fill brush unless fill is 0.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a plain rectangle:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle(QFrame::Box | QFrame::Plain);</para>
                <para>See also qDrawShadeRect() and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawShadeLine(QtGui.QPainter,QtCore.QPoint,QtCore.QPoint,QtGui.QPalette,System.Boolean,System.Int32,System.Int32)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Draws a horizontal or vertical shaded line between p1 and p2 using the given painter. Note that nothing is drawn if the line between the points would be neither horizontal nor vertical.</para>
                <para>The provided palette specifies the shading colors (light, dark and middle colors). The given lineWidth specifies the line width for each of the lines; it is not the total line width. The given midLineWidth specifies the width of a middle line drawn in the QPalette::mid() color.</para>
                <para>The line appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a shaded line:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle(QFrame::HLine | QFrame::Sunken);</para>
                <para>See also qDrawShadeRect(), qDrawShadePanel(), and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawShadeLine(QtGui.QPainter,System.Int32,System.Int32,System.Int32,System.Int32,QtGui.QPalette,System.Boolean,System.Int32,System.Int32)">
            <summary>
                <para>Draws a horizontal (y1 == y2) or vertical (x1 == x2) shaded line using the given painter. Note that nothing is drawn if y1 != y2 and x1 != x2 (i.e. the line is neither horizontal nor vertical).</para>
                <para>The provided palette specifies the shading colors (light, dark and middle colors). The given lineWidth specifies the line width for each of the lines; it is not the total line width. The given midLineWidth specifies the width of a middle line drawn in the QPalette::mid() color.</para>
                <para>The line appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a shaded line:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle(QFrame::HLine | QFrame::Sunken);</para>
                <para>See also qDrawShadeRect(), qDrawShadePanel(), and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawShadePanel(QtGui.QPainter,QtCore.QRect,QtGui.QPalette,System.Boolean,System.Int32,QtGui.QBrush)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Draws the shaded panel at the rectangle specified by rect using the given painter and the given lineWidth.</para>
                <para>The given palette specifies the shading colors (light, dark and middle colors). The panel's interior is filled with the fill brush unless fill is 0.</para>
                <para>The panel appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a shaded panel:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle( QFrame::Panel | QFrame::Sunken);</para>
                <para>See also qDrawWinPanel(), qDrawShadeLine(), qDrawShadeRect(), and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawShadePanel(QtGui.QPainter,System.Int32,System.Int32,System.Int32,System.Int32,QtGui.QPalette,System.Boolean,System.Int32,QtGui.QBrush)">
            <summary>
                <para>Draws the shaded panel beginning at (x, y) with the given width and height using the provided painter and the given lineWidth.</para>
                <para>The given palette specifies the shading colors (light, dark and middle colors). The panel's interior is filled with the fill brush unless fill is 0.</para>
                <para>The panel appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a shaded panel:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle( QFrame::Panel | QFrame::Sunken);</para>
                <para>See also qDrawWinPanel(), qDrawShadeLine(), qDrawShadeRect(), and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawShadeRect(QtGui.QPainter,QtCore.QRect,QtGui.QPalette,System.Boolean,System.Int32,System.Int32,QtGui.QBrush)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Draws the shaded rectangle specified by rect using the given painter.</para>
                <para>The provide palette specifies the shading colors (light, dark and middle colors. The given lineWidth specifies the line width for each of the lines; it is not the total line width. The midLineWidth specifies the width of a middle line drawn in the QPalette::mid() color. The rectangle's interior is filled with the fill brush unless fill is 0.</para>
                <para>The rectangle appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a shaded rectangle:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle(QFrame::Box | QFrame::Raised);</para>
                <para>See also qDrawShadeLine(), qDrawShadePanel(), qDrawPlainRect(), and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawShadeRect(QtGui.QPainter,System.Int32,System.Int32,System.Int32,System.Int32,QtGui.QPalette,System.Boolean,System.Int32,System.Int32,QtGui.QBrush)">
            <summary>
                <para>Draws the shaded rectangle beginning at (x, y) with the given width and height using the provided painter.</para>
                <para>The provide palette specifies the shading colors (light, dark and middle colors. The given lineWidth specifies the line width for each of the lines; it is not the total line width. The midLineWidth specifies the width of a middle line drawn in the QPalette::mid() color. The rectangle's interior is filled with the fill brush unless fill is 0.</para>
                <para>The rectangle appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a shaded rectangle:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle(QFrame::Box | QFrame::Raised);</para>
                <para>See also qDrawShadeLine(), qDrawShadePanel(), qDrawPlainRect(), and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawWinButton(QtGui.QPainter,QtCore.QRect,QtGui.QPalette,System.Boolean,QtGui.QBrush)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Draws the Windows-style button at the rectangle specified by rect using the given painter with a line width of 2 pixels. The button's interior is filled with the fill brush unless fill is 0.</para>
                <para>The given palette specifies the shading colors (light, dark and middle colors).</para>
                <para>The button appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style()-&gt; Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>See also qDrawWinPanel() and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawWinButton(QtGui.QPainter,System.Int32,System.Int32,System.Int32,System.Int32,QtGui.QPalette,System.Boolean,QtGui.QBrush)">
            <summary>
                <para>Draws the Windows-style button specified by the given point (x, y}, width and height using the provided painter with a line width of 2 pixels. The button's interior is filled with the fill brush unless fill is 0.</para>
                <para>The given palette specifies the shading colors (light, dark and middle colors).</para>
                <para>The button appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style()-&gt; Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>See also qDrawWinPanel() and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QDrawWinPanel(QtGui.QPainter,System.Int32,System.Int32,System.Int32,System.Int32,QtGui.QPalette,System.Boolean,QtGui.QBrush)">
            <summary>
                <para>Draws the Windows-style panel specified by the given point(x, y), width and height using the provided painter with a line width of 2 pixels. The button's interior is filled with the fill brush unless fill is 0.</para>
                <para>The given palette specifies the shading colors. The panel appears sunken if sunken is true, otherwise raised.</para>
                <para>Warning: This function does not look at QWidget::style() or QApplication::style(). Use the drawing functions in QStyle to make widgets that follow the current GUI style.</para>
                <para>Alternatively you can use a QFrame widget and apply the QFrame::setFrameStyle() function to display a shaded panel:</para>
                <para> QFrame frame:</para>
                <para> frame.setFrameStyle(QFrame::WinPanel | QFrame::Raised);</para>
                <para>See also qDrawShadePanel(), qDrawWinButton(), and QStyle.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QExp(System.Double)">
            <summary>
                <para>Returns the exponential function of e to the power of v.</para>
                <para>See also qLn().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QFloor(System.Double)">
            <summary>
                <para>Return the floor of the value v.</para>
                <para>The floor is the largest integer that is not greater than v. For example, if v is 41.2, then the floor is 41.</para>
                <para>See also qCeil().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QFuzzyCompare(System.Double,System.Double)">
            <summary>
                <para>Compares the floating point value p1 and p2 and returns true if they are considered equal, otherwise false.</para>
                <para>Note that comparing values where either p1 or p2 is 0.0 will not work. The solution to this is to compare against values greater than or equal to 1.0.</para>
                <para>         // Instead of comparing with 0.0</para>
                <para>                 qFuzzyCompare(0.0,1.0e-200); // This will return false</para>
                <para>         // Compare adding 1 to both values will fix the problem</para>
                <para>                 qFuzzyCompare(1 + 0.0, 1 + 1.0e-200); // This will return true</para>
                <para>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</para>
                <para>Note: This function is thread-safe.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QFuzzyCompare(System.Single,System.Single)">
            <summary>
                <para>Compares the floating point value p1 and p2 and returns true if they are considered equal, otherwise false.</para>
                <para>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</para>
                <para>Note: This function is thread-safe.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(QtCore.QBitArray)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(QtCore.QByteArray)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(QtCore.QChar)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.Byte)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.String)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.UInt16)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(NativeLong)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.Int64)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.UInt64)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.Char)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.Int16)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(NativeULong)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.UInt32)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QHash(System.Int32)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QInstallMsgHandler(QtOpenGL.Global.ActionQtMsgTypeString)">
            <summary>
                <para>Installs a Qt message handler which has been defined previously. Returns a pointer to the previous message handler (which may be 0).</para>
                <para>The message handler is a function that prints out debug messages, warnings, critical and fatal error messages. The Qt library (debug mode) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. Qt built in release mode also contains such warnings unless QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during compilation. If you implement your own message handler, you get total control of these messages.</para>
                <para>The default message handler prints the message to the standard output under X11 or to the debugger under Windows. If it is a fatal message, the application aborts immediately.</para>
                <para>Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.</para>
                <para>To restore the message handler, call qInstallMsgHandler(0).</para>
                <para>Example:</para>
                <para> #include &lt;qapplication.h&gt;</para>
                <para> #include &lt;stdio.h&gt;</para>
                <para> #include &lt;stdlib.h&gt;</para>
                <para>
                </para>
                <para> void myMessageOutput(QtMsgType type, const char *msg)</para>
                <para> {</para>
                <para>     switch (type) {</para>
                <para>     case QtDebugMsg:</para>
                <para>         fprintf(stderr, "Debug: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtWarningMsg:</para>
                <para>         fprintf(stderr, "Warning: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtCriticalMsg:</para>
                <para>         fprintf(stderr, "Critical: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtFatalMsg:</para>
                <para>         fprintf(stderr, "Fatal: %s\\n", msg);</para>
                <para>         abort();</para>
                <para>     }</para>
                <para> }</para>
                <para>
                </para>
                <para> int main(int argc, char **argv)</para>
                <para> {</para>
                <para>     qInstallMsgHandler(myMessageOutput);</para>
                <para>     QApplication app(argc, argv);</para>
                <para>     ...</para>
                <para>     return app.exec();</para>
                <para> }</para>
                <para>See also qDebug(), qWarning(), qCritical(), qFatal(), QtMsgType, and Debugging Techniques.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QLn(System.Double)">
            <summary>
                <para>Returns the natural logarithm of v. Natural logarithm uses base e.</para>
                <para>See also qExp().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QPow(System.Double,System.Double)">
            <summary>
                <para>Returns the value of x raised to the power of y. That is, x is the base and y is the exponent.</para>
                <para>See also qSqrt().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QRound(System.Double)">
            <summary>
                <para>Rounds value to the nearest integer.</para>
                <para>Example:</para>
                <para> qreal valueA = 2.3;</para>
                <para> qreal valueB = 2.7;</para>
                <para>
                </para>
                <para> int roundedValueA = qRound(valueA);</para>
                <para> // roundedValueA = 2</para>
                <para> int roundedValueB = qRound(valueB);</para>
                <para> // roundedValueB = 3</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QRound64(System.Double)">
            <summary>
                <para>Rounds value to the nearest 64-bit integer.</para>
                <para>Example:</para>
                <para> qreal valueA = 42949672960.3;</para>
                <para> qreal valueB = 42949672960.7;</para>
                <para>
                </para>
                <para> int roundedValueA = qRound(valueA);</para>
                <para> // roundedValueA = 42949672960</para>
                <para> int roundedValueB = qRound(valueB);</para>
                <para> // roundedValueB = 42949672961</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QSin(System.Double)">
            <summary>
                <para>Returns the sine of the angle v in radians.</para>
                <para>See also qCos() and qTan().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QSqrt(System.Double)">
            <summary>
                <para>Returns the square root of v. This function returns a NaN if v is a negative number.</para>
                <para>See also qPow().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QTan(System.Double)">
            <summary>
                <para>Returns the tangent of an angle v in radians.</para>
                <para>See also qSin() and qCos().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.Qgetenv(System.String)">
            <summary>
                <para>Returns the value of the environment variable with name varName. To get the variable string, use QByteArray::constData().</para>
                <para>Note: qgetenv() was introduced because getenv() from the standard C library was deprecated in VC2005 (and later versions). qgetenv() uses the new replacement function in VC, and calls the standard C library's implementation on all other platforms.</para>
                <para>See also qputenv().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.Qputenv(System.String,QtCore.QByteArray)">
            <summary>
                <para>This function sets the value of the environment variable named varName. It will create the variable if it does not exist. It returns 0 if the variable could not be set.</para>
                <para>Note: qputenv() was introduced because putenv() from the standard C library was deprecated in VC2005 (and later versions). qputenv() uses the replacement function in VC, and calls the standard C library's implementation on all other platforms.</para>
                <para>See also qgetenv().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.Qsrand(System.UInt32)">
            <summary>
                <para>Thread-safe version of the standard C++ srand() function.</para>
                <para>Sets the argument seed to be used to generate a new random number sequence of pseudo random integers to be returned by qrand().</para>
                <para>The sequence of random numbers generated is deterministic per thread. For example, if two threads call qsrand(1) and subsequently calls qrand(), the threads will get the same random number sequence.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also qrand().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.Global.QtTrId(System.String,System.Int32)">
            <summary>
                <para>The qtTrId function finds and returns a translated string.</para>
                <para>Returns a translated string identified by id. If no matching string is found, the id itself is returned. This should not happen under normal conditions.</para>
                <para>If n &gt;= 0, all occurrences of %n in the resulting string are replaced with a decimal representation of n. In addition, depending on n's value, the translation text may vary.</para>
                <para>Meta data and comments can be passed as documented for QObject::tr(). In addition, it is possible to supply a source string template like that:</para>
                <para>//% &lt;C string&gt;</para>
                <para>or</para>
                <para>/*% &lt;C string&gt; */</para>
                <para>Example:</para>
                <para>     //% "%n fooish bar(s) found.\\n"</para>
                <para>     //% "Do you want to continue?"</para>
                <para>     QString text = qtTrId("qtn_foo_bar", n);</para>
                <para>Creating QM files suitable for use with this function requires passing the -idbased option to the lrelease tool.</para>
                <para>Warning: This method is reentrant only if all translators are installed before calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.</para>
                <para>Note: This function is reentrant.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also QObject::tr(), QCoreApplication::translate(), and Internationalization with Qt.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QtMsgType">
            <summary>
                <para>This enum describes the messages that can be sent to a message handler (QtMsgHandler). You can use the enum to identify and associate the various message types with the appropriate actions.</para>
                <para>See also QtMsgHandler and qInstallMsgHandler().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QtMsgType.QtCriticalMsg">
            <summary>
                <para>A message generated by the qCritical() function.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QtMsgType.QtDebugMsg">
            <summary>
                <para>A message generated by the qDebug() function.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QtMsgType.QtFatalMsg">
            <summary>
                <para>A message generated by the qFatal() function.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QtMsgType.QtWarningMsg">
            <summary>
                <para>A message generated by the qWarning() function.</para>
            </summary>
        </member>
    </members>
</doc>
