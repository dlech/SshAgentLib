<?xml version="1.0"?>
<doc>
    <assembly>
        <name>qyoto-qtxmlpatterns</name>
    </assembly>
    <members>
        <member name="T:QtXmlPatterns.QAbstractMessageHandler">
            <summary>
            The QAbstractMessageHandler class provides a callback interface for handling messages.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QAbstractMessageHandler is an abstract base class that provides a callback interface for handling messages. For example, class QXmlQuery parses and runs an XQuery. When it detects a compile or runtime error, it generates an appropriate error message, but rather than output the message itself, it passes the message to the message() function of its QAbstractMessageHandler. See QXmlQuery::setMessageHandler().</para>
                <para>You create a message handler by subclassing QAbstractMessageHandler and implementing handleMessage(). You then pass a pointer to an instance of your subclass to any classes that must generate messages. The messages are sent to the message handler via the message() function, which forwards them to your handleMessge(). The effect is to serialize the handling of all messages, which means your QAbstractMessageHandler subclass is thread safe.</para>
                <para>A single instance of QAbstractMessageHandler can be called on to handle messages from multiple sources. Hence, the content of a message, which is the description parameter passed to message() and handleMessage(), must be interpreted in light of the context that required the message to be sent. That context is specified by the identifier and sourceLocation parameters to message() handleMessage().</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QAbstractMessageHandler.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QAbstractMessageHandler. The parent is passed to the QObject base class constructor.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractMessageHandler.HandleMessage(QtXmlPatterns.QtMsgType,System.String,QtCore.QUrl,QtXmlPatterns.QSourceLocation)">
            <summary>
                <para>This function must be implemented by the sub-class. message() will call this function, passing in its parameters, type, description, identifier and sourceLocation unmodified.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractMessageHandler.Message(QtXmlPatterns.QtMsgType,System.String)">
            <summary>
                <para>Sends a message to this message handler. type is the kind of message being sent. description is the message content. The identifier is a URI that identifies the message and is the key to interpreting the other arguments.</para>
                <para>Typically, this class is used for reporting errors, as is the case for QXmlQuery, which uses a QAbstractMessageHandler to report compile and runtime XQuery errors. Hence, using a QUrl as the message identifier is was inspired by the explanation of error handling in the XQuery language. Because the identifier is composed of a namespace URI and a local part, identifiers with the same local part are unique. The caller is responsible for ensuring that identifier is either a valid QUrl or a default constructed QUrl.</para>
                <para>sourceLocation identifies a location in a resource (i.e., file or document) where the need for reporting a message was detected.</para>
                <para>This function unconditionally calls handleMessage(), passing all its parameters unmodified.</para>
                <para>See also http://www.w3.org/TR/xquery/#errors.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractMessageHandler.Message(QtXmlPatterns.QtMsgType,System.String,QtCore.QUrl)">
            <summary>
                <para>Sends a message to this message handler. type is the kind of message being sent. description is the message content. The identifier is a URI that identifies the message and is the key to interpreting the other arguments.</para>
                <para>Typically, this class is used for reporting errors, as is the case for QXmlQuery, which uses a QAbstractMessageHandler to report compile and runtime XQuery errors. Hence, using a QUrl as the message identifier is was inspired by the explanation of error handling in the XQuery language. Because the identifier is composed of a namespace URI and a local part, identifiers with the same local part are unique. The caller is responsible for ensuring that identifier is either a valid QUrl or a default constructed QUrl.</para>
                <para>sourceLocation identifies a location in a resource (i.e., file or document) where the need for reporting a message was detected.</para>
                <para>This function unconditionally calls handleMessage(), passing all its parameters unmodified.</para>
                <para>See also http://www.w3.org/TR/xquery/#errors.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractMessageHandler.Message(QtXmlPatterns.QtMsgType,System.String,QtCore.QUrl,QtXmlPatterns.QSourceLocation)">
            <summary>
                <para>Sends a message to this message handler. type is the kind of message being sent. description is the message content. The identifier is a URI that identifies the message and is the key to interpreting the other arguments.</para>
                <para>Typically, this class is used for reporting errors, as is the case for QXmlQuery, which uses a QAbstractMessageHandler to report compile and runtime XQuery errors. Hence, using a QUrl as the message identifier is was inspired by the explanation of error handling in the XQuery language. Because the identifier is composed of a namespace URI and a local part, identifiers with the same local part are unique. The caller is responsible for ensuring that identifier is either a valid QUrl or a default constructed QUrl.</para>
                <para>sourceLocation identifies a location in a resource (i.e., file or document) where the need for reporting a message was detected.</para>
                <para>This function unconditionally calls handleMessage(), passing all its parameters unmodified.</para>
                <para>See also http://www.w3.org/TR/xquery/#errors.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractMessageHandler.Finalize">
            <summary>
                <para>Destructs this QAbstractMessageHandler.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QAbstractUriResolver">
            <summary>
            The QAbstractUriResolver class is a callback interface for resolving Uniform Resource Identifiers.
            </summary>
            <remarks>
                <para>
                </para>
                <para>A Uniform Resource Identifier (URI) is a string that uniquely identifies a resource. URIs are versatile global identifiers. It is often useful to transform a URI that identifies something logical into a URI that locates something physical (a URL), or to simply map a URI to a different URI. QAbstractUriResolver::resolve() provides this functionality.</para>
                <para>For example, one could write a QAbstractUriResolver subclass that rewrites library ISBN number URIs as book title URLs, e.g., urn:isbn:0-345-33973-8 would be rewritten as file:///books/returnOfTheKing.doc. Or a QAbstractUriResolver subclass could be written for a web browser to let the web browser protect the user's private files by mapping incoming requests for them to null URIs.</para>
                <para>
                </para>
                <para>See also http://en.wikipedia.org/wiki/Uniform_Resource_Identifier.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QAbstractUriResolver.#ctor(QtCore.QObject)">
            <summary>
                <para>Constructs a QAbstractUriResolver with the specified parent.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractUriResolver.Resolve(QtCore.QUrl,QtCore.QUrl)">
            <summary>
                <para>Returns the relative URI resolved using the baseURI.</para>
                <para>The caller guarantees that both relative and baseURI are valid, and that baseURI is absolute. relative can be relative, absolute, or empty.</para>
                <para>The returned QUrl can be a default constructed QUrl. If it is not a default constructed QUrl, it will be absolute and valid. If a default constructed QUrl is returned, it means the relative URI was not accepted to be resolved.</para>
                <para>If the reimplemented resolve() function decides it has nothing to do about resolving the relative URI, it should simply return the relative URI resolved against the baseURI, i.e.:</para>
                <para> return baseURI.resolved(relative);</para>
                <para>See also QUrl::isRelative() and QUrl::isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractUriResolver.Finalize">
            <summary>
                <para>Destructor.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QAbstractXmlNodeModel">
            <summary>
            The QAbstractXmlNodeModel class is an abstract base class for modeling non-XML data to look like XML for QXmlQuery.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QAbstractXmlNodeModel specifies the interface that a node model must implement for that node model be accessible to the query engine for processing XQuery queries. A node model represents data as a structure that can be queried as if the data were XML.</para>
                <para>The node model represented by a subclass of QAbstractXmlNodeModel is meant to be accessed by the QtXmlPatterns query engine. If the API seems a little strange in a few places, it is because the member functions are called by the query engine as it evaluates an XQuery. They aren't meant to be used programatically.</para>
                <para>
                </para>
                <para>Usage</para>
                <para>QAbstractXmlNodeModel bridges the gap between the arbitrary structure of the non-XML data to be queried and the well-defined structure of XML data understood by QXmlQuery.</para>
                <para>Consider a chemistry application that reads the file chemistryData, which contains non-XML data that represents a chemical structure composed of molecules and atoms. The application will query this chemistry data with an XQuery it reads from file queryFile. We write a custom subclass of QAbstractXmlNodeModel (ChemistryNodeModel) that reads chemistryData and builds a data structure, perhaps composed of objects of our own classes molecule and atom. Clearly, this data structure is not XML. Our custom subclass will know how to traverse this non-XML structure and present it through the XPath Data Model interface.</para>
                <para> QFile queryFile(argv[1]);</para>
                <para> QFile chemistryData(argv[2]);</para>
                <para> QString moleculeName = argv[3];</para>
                <para>
                </para>
                <para> QXmlQuery query;</para>
                <para> query.setQuery(&amp;queryFile, QUrl::fromLocalFile(queryFile.fileName()));</para>
                <para>
                </para>
                <para> ChemistryNodeModel myNodeModel(query.namePool(), chemistryData);</para>
                <para> QXmlNodeModelIndex startNode = myNodeModel.nodeFor(moleculeName);</para>
                <para> query.bindVariable("queryRoot", startNode);</para>
                <para>
                </para>
                <para> QFile out;</para>
                <para> out.open(stdout, QIODevice::WriteOnly);</para>
                <para>
                </para>
                <para> QXmlSerializer serializer(query, &amp;out);</para>
                <para> query.evaluateTo(&amp;serializer);</para>
                <para>The application first creates an instance of QXmlQuery and calls setQuery() to read queryFile containing the XQuery we want to run. Then it creates an instance of our custom node model class, ChemistryNodeModel, which is a subclass of QAbstractXmlNodeModel. Its constructor is called with the name pool obtained from our QXmlQuery, and with the chemistryFile containing the structure of molecules and atoms to be queried. The name pool is required because our custom node model has the member function name(), which returns the name of any node in the model. The query and the custom node model must use the same name pool for constructing these names. The constructor would then read chemistryFile and build the custom node model structure.</para>
                <para>To connect the query to the custom node model, we must bind a variable name used in the query to a node in the model. The variable can then be used in the query as a starting node. First, an index for the desired starting node is retrieved by calling QAbstractXmlNodeModel::createIndex(). Then the index is bound to a variable name, in this case queryRoot, by passing the name and the index to QXmlQuery::bindVariable(). The query can then use a variable reference $queryRoot to refer to the starting node. Note that if the query uses multiple variable references, a call to QXmlQuery::bindVariable() is required to bind each different variable name to a node in the model.</para>
                <para>The query is executed when the application calls one of the QXmlQuery evaluation functions. The application uses QXmlQuery::evaluateTo(QAbstractXmlReceiver *), because it then uses a serializer to out the query result as XML to stdout. We could have used QXmlQuery::evaluateTo(QXmlResultItems *) to get a list of result items, or QXmlQuery::evaluateTo(QStringList *) if the query evaluated to a sequence of xs:string values.</para>
                <para>During query execution, the engine iterates over the node model using nextFromSimpleAxis() to get the index of the next node to be visited. The engine can get the name of a node by calling name() with the node's index. stringValue(), baseUri(), documentUri() and kind() are also called as needed with a node index.</para>
                <para>The example demonstrates the standard pattern for using a subclass of QAbstractXmlNodeModel in combination with QXmlQuery to perform an XQuery.</para>
                <para>
                </para>
                <para>Instantiate QXmlQuery and give it the XQuery to be run;</para>
                <para>Instantiate a subclass of QAbstractXmlNodeModel or QSimpleXmlNodeModel;</para>
                <para>Retrieve a QXmlNodeModelIndex for the node in the model where the QXmlQuery should start the query;</para>
                <para>Use QXmlQuery::bindVariable() to bind the QXmlNodeModelIndex to $variable name;</para>
                <para>Call one of the QXmlQuery evaluation functions to run the query.</para>
                <para>
                </para>
                <para>
                </para>
                <para>Subclassing</para>
                <para>Because the XPath Data Model interface presented by QAbstractXmlNodeModel allows QXmlQuery to operate on non-XML data as if it were XML, implementing subclasses of QAbstractXmlNodeModel can involve a significant amount of work. The QSimpleXmlNodeModel class is provided to simplify the implementation for many common use cases.</para>
                <para>
                </para>
                <para>Thread Safety</para>
                <para>Because the node model can be accessed concurrently by threads in the QtXmlPatterns module, subclasses of QAbstractXmlNodeModel must be written to be thread-safe. Classes that simplify implementing thread-safety include QReadLocker and QWriteLocker.</para>
                <para>See the example File System Example for a demonstration.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.#ctor">
            <summary>
                <para>Default constructor.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QAbstractXmlNodeModel.SimpleAxis">
            <summary>
                <para>Four axes that each contain one node only.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QAbstractXmlNodeModel.SimpleAxis.FirstChild">
            <summary>
                <para>The first child of the context node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QAbstractXmlNodeModel.SimpleAxis.NextSibling">
            <summary>
                <para>The next child of the context node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QAbstractXmlNodeModel.SimpleAxis.Parent">
            <summary>
                <para>The parent of the context node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QAbstractXmlNodeModel.SimpleAxis.PreviousSibling">
            <summary>
                <para>The previous child of the context node</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.Attributes(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the attributes of element. The caller guarantees that element is an element in this node model.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.BaseUri(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the base URI for the node whose index is n. The caller guarantees that n is not null and that it belongs to a node in this node model.</para>
                <para>The base URI of a node can be extracted using the fn:base-uri() function. The base URI is typically used for resolving relative URIs that appear in the node or its children. It is conformant to just return the document URI, although that might not properly reflect the underlying data.</para>
                <para>This function maps to the dm:base-uri accessor, which returns a base URI according to the following:</para>
                <para>
                </para>
                <para>For document nodes, the base URI and the document URI are the same.</para>
                <para>For elements, the base URI is the URI appearing in the element's xml:base attribute, if present, or it is resolved to the parent element's base URI.</para>
                <para>Namespace nodes have no base URI.</para>
                <para>The base URI for a processing instruction, comment, attribute, or text node is the base URI of the node's parent element.</para>
                <para>
                </para>
                <para>The implementation guarantees to return a valid QUrl, or a default constructed QUrl. If a node has no base URI, as in the case where a comment has no parent, a default constructed QUrl is returned.</para>
                <para>See also XQuery 1.0 and XPath 2.0 Data Model (XDM), 5.2 base-uri Accessor.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.CompareOrder(QtXmlPatterns.QXmlNodeModelIndex,QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>This function returns the relative document order for the nodes indexed by ni1 and ni2. It is used for the Is operator and for sorting nodes in document order.</para>
                <para>The caller guarantees that ni1 and ni2 are not null and that both identify nodes in this node model.</para>
                <para>If ni1 is identical to ni2, QXmlNodeModelIndex::Is is returned. If ni1 precedes ni2 in document order, QXmlNodeModelIndex::Precedes is returned. If ni1 follows ni2 in document order, QXmlNodeModelIndex::Follows is returned.</para>
                <para>See also XQuery 1.0 and XPath 2.0 Data Model (XDM), 2.4 Document Order.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.CreateIndex(System.Int64)">
            <summary>
                <para>Creates a node index with data as its internal data. data is not constrained.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.CreateIndex(System.Int64,System.Int64)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Creates a QXmlNodeModelIndex containing data and additionalData.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.DocumentUri(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the document URI of n. The document URI identifies the resource which is the document. For example, the document could be a regular file, e.g., file:/, or it could be the http:// URL of the location of a file. The document URI is used for resolving URIs and to simply know where the document is.</para>
                <para>If the node model maps to a URI in a natural way, return that URI. Otherwise, return the company or product URI. The document URI can be any URI as long as its valid and absolute.</para>
                <para>The caller guarantees that n is not null and that it belongs to this QAbstractXmlNodeModel.</para>
                <para>This function maps to the dm:document-uri accessor, which returns a document URI according to the following:</para>
                <para>
                </para>
                <para>If n is a document node, return an absolute QUrl containing the document URI, or a default constructed QUrl. The latter signals that no document URI is available for the document node.</para>
                <para>For all other nodes, return a default constructed QUrl.</para>
                <para>
                </para>
                <para>See also XQuery 1.0 and XPath 2.0 Data Model (XDM), 5.4 document-uri Accessor, QUrl::isValid(), and QUrl::isRelative().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.ElementById(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Returns the index of the element identified as id. XQuery's id() function calls this function.</para>
                <para>The node index returned will be the element node whose value is of type ID and equals id, or it will be the element node that has an attribute whose typed value is of type ID and equals id. If there is no such element, a default constructed QXmlNodeModelIndex instance is returned. The implementor guarantees that if the returned node index is not null, it identifies an element.</para>
                <para>It is not sufficient for an attribute or element to merely be called id. Its value type must also be ID. However, the reserved name xml:id is sufficient.</para>
                <para>In id, the namespace URI and the prefix are undefined, and the local name is the ID that should be looked up.</para>
                <para>See also XQuery 1.0 and XPath 2.0 Functions and Operators, 15.5.2 fn:id.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.Kind(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns a value indicating the kind of node identified by ni. The caller guarantees that ni is not null and that it identifies a node in this node model. This function maps to the dm:node-kind() accessor.</para>
                <para>See also XQuery 1.0 and XPath 2.0 Data Model (XDM), 5.10 node-kind Accessor.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.Name(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the name of ni. The caller guarantees that ni is not null and that it belongs to this QAbstractXmlNodeModel.</para>
                <para>If a node does not have a name, e.g., comment nodes, a null QXmlName is returned. QXmlNames must be created with the instance of QXmlQuery that is being used for evaluating queries using this QAbstractXmlNodeModel.</para>
                <para>This function maps to the dm:node-name() accessor.</para>
                <para>If ni is a processing instruction, a QXmlName is returned with the local name as the target name and the namespace URI and prefix both empty.</para>
                <para>See also XQuery 1.0 and XPath 2.0 Data Model (XDM), 5.11 node-name Accessor and QXmlName.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.NamespaceBindings(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the in-scope namespaces of n. The caller guarantees that n is not null and that it belongs to this QAbstractXmlNodeModel.</para>
                <para>This function corresponds to the dm:namespace-nodes accessor.</para>
                <para>The returned vector of namespace declarations includes namespaces of the ancestors of n.</para>
                <para>The caller guarantees that n is an Element that belongs to this QAbstractXmlNodeModel.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.NextFromSimpleAxis(QtXmlPatterns.QAbstractXmlNodeModel.SimpleAxis,QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>When QtXmlPatterns evaluate path expressions, it emulate them through a combination of calls with QSimpleXmlNodeModel::SimpleAxis values. Therefore, the implementation of this function must return the node, if any, that appears on the axis emanating from the origin.</para>
                <para>If no such node is available, a default constructed QXmlNodeModelIndex is returned.</para>
                <para>QSimpleXmlNodeModel eliminates the need to handle redundant corner cases by guaranteeing that it will never ask for:</para>
                <para>
                </para>
                <para>Children or siblings for attributes.</para>
                <para>Children for comments, processing instructions, and text nodes.</para>
                <para>Siblings or parents for document nodes.</para>
                <para>
                </para>
                <para>A typical implementation performs a switch on the value of axis:</para>
                <para> QXmlNodeModelIndex MyTreeModel::nextFromSimpleAxis(SimpleAxis axis, const QXmlNodeModelIndex &amp;origin) const</para>
                <para> {</para>
                <para>   // Convert the QXmlNodeModelIndex to a value that is specific to what we represent.</para>
                <para>   const MyValue value = toMyValue(ni);</para>
                <para>
                </para>
                <para>   switch(axis)</para>
                <para>   {</para>
                <para>       case Parent:</para>
                <para>           return toNodeIndex(value.parent());</para>
                <para>       case FirstChild:</para>
                <para>       case PreviousSibling:</para>
                <para>       case NextSibling:</para>
                <para>           // and so on</para>
                <para>   }</para>
                <para> }</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.NodesByIdref(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Returns the elements and/or attributes that have an IDREF value equal to idref. XQuery's idref() function calls this function.</para>
                <para>The implementor guarantees that the nodes identified by the returned indexes are elements or attributes.</para>
                <para>It is not sufficient for an attribute or element to merely be called idref. It must also be of type IDREF. Elements must be typed as xs:IDREF or xs:IDREFS, or, in the case of attributes, as IDREF or IDREFS in the schema.</para>
                <para>In idref, the namespace URI and the prefix are undefined, and the local name is the ID that should be looked up.</para>
                <para>See also XQuery 1.0 and XPath 2.0 Functions and Operators, 15.5.3 fn:idref.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.Root(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the root node of the tree that contains the node whose index is n. The caller guarantees that n is not null and that it identifies a node in this node model.</para>
                <para>If n identifies a node that is a direct child of the root, parent() would return the same QXmlNodeModelIndex returned by this function.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.SourceLocation(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the source location for the object with the given index or a default constructed QSourceLocation in case no location information is available.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.StringValue(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the string value for node n.</para>
                <para>The caller guarantees that n is not null and that it belong to this QAbstractXmlNodeModel instance.</para>
                <para>This function maps to the dm:string-value() accessor, which the specification completely specifies. Here's a summary:</para>
                <para>
                </para>
                <para>For processing instructions, the string value is the data section(excluding any whitespace appearing between the name and the data).</para>
                <para>For text nodes, the string value equals the text node.</para>
                <para>For comments, the content of the comment</para>
                <para>For elements, the concatenation of all text nodes that are descendants. Note, this is not only the children, but the childrens' childrens' text nodes, and so forth.</para>
                <para>For document nodes, the concatenation of all text nodes in the document.</para>
                <para>
                </para>
                <para>See also XQuery 1.0 and XPath 2.0 Data Model (XDM), 5.13 string-value Accessor.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.TypedValue(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns the typed value for node node.</para>
                <para>The typed value is an atomic value, which an element or attribute contains.</para>
                <para>The caller guarantees that node is either an element or an attribute. The implementor guarantees that the returned QVariant has a value which is supported in XQuery. It cannot be an arbitrary QVariant value. The implementor also guarantees that stringValue() returns a lexical representation of typedValue()(this is guaranteed by QSimpleXmlNodeModel::stringValue()).</para>
                <para>If the return QVariant is a default constructed variant, it signals that node has no typed value.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlNodeModel.Finalize">
            <summary>
                <para>Destructor.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QAbstractXmlReceiver">
            <summary>
            The QAbstractXmlReceiver class provides a callback interface for transforming the output of a QXmlQuery.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QAbstractXmlReceiver is an abstract base class that provides a callback interface for receiving an XQuery sequence, usually the output of an QXmlQuery, and transforming that sequence into a structure of your choosing, usually XML. Consider the example:</para>
                <para> QXmlQuery query;</para>
                <para> query.setQuery("doc('index.html')/html/body/p[1]");</para>
                <para>
                </para>
                <para> QXmlSerializer serializer(query, myOutputDevice);</para>
                <para> query.evaluateTo(&amp;serializer);</para>
                <para>First it constructs a query that gets the first paragraph from document index.html. Then it constructs an XML serializer with the query and myOutputDevice (Note the serializer is an XML receiver, ie a subclass of QAbstractXmlReceiver). Finally, it evaluates the query, producing an ordered sequence of calls to the serializer's callback functions. The sequence of callbacks transforms the query output to XML and writes it to myOutputDevice.</para>
                <para>Although the example uses QXmlQuery to produce the sequence of callbacks to functions in QAbstractXmlReceiver, you can call the callback functions directly as long as your sequence of calls represents a valid XQuery sequence.</para>
                <para>
                </para>
                <para>XQuery Sequences</para>
                <para>An XQuery sequence is an ordered collection of zero, one, or many items. Each item is either an atomic value or a node. An atomic value is a simple data value.</para>
                <para>There are six kinds of nodes.</para>
                <para>
                </para>
                <para>An Element Node represents an XML element.</para>
                <para>An Attribute Node represents an XML attribute.</para>
                <para>A Document Node represents an entire XML document.</para>
                <para>A Text Node represents character data (element content).</para>
                <para>A Processing Instruction Node represents an XML processing instruction, which is used in an XML document to tell the application reading the document to perform some action. A typical example is to use a processing instruction to tell the application to use a particular XSLT stylesheet to display the document.</para>
                <para>And a Comment node represents an XML comment.</para>
                <para>
                </para>
                <para>The sequence of nodes and atomic values obeys the following rules. Note that Namespace Node refers to a special Attribute Node with name xmlns.</para>
                <para>
                </para>
                <para>Each node appears in the sequence before its children and their descendants appear.</para>
                <para>A node's descendants appear in the sequence before any of its siblings appear.</para>
                <para>A Document Node represents an entire document. Zero or more Document Nodes can appear in a sequence, but they can only be top level items (i.e., a Document Node can't be a child of another node.</para>
                <para>Namespace Nodes immediately follow the Element Node with which they are associated.</para>
                <para>Attribute Nodes immediately follow the Namespace Nodes of the element with which they are associated, or...</para>
                <para>If there are no Namespace Nodes following an element, then the Attribute Nodes immediately follow the element.</para>
                <para>An atomic value can only appear as a top level item, i.e., it can't appear as a child of a node.</para>
                <para>Processing Instruction Nodes do not have children, and their parent is either a Document Node or an Element Node.</para>
                <para>Comment Nodes do not have children, and their parent is either a Document Node or an Element Node.</para>
                <para>
                </para>
                <para>The sequence of nodes and atomic values is sent to an QAbstractXmlReceiver (QXmlSerializer in the example above) as a sequence of calls to the receiver's callback functions. The mapping of callback functions to sequence items is as follows.</para>
                <para>
                </para>
                <para>startDocument() and endDocument() are called for each Document Node in the sequence. endDocument() is not called until all the Document Node's children have appeared in the sequence.</para>
                <para>startElement() and endElement() are called for each Element Node. endElement() is not called until all the Element Node's children have appeared in the sequence.</para>
                <para>attribute() is called for each Attribute Node.</para>
                <para>comment() is called for each Comment Node.</para>
                <para>characters() is called for each Text Node.</para>
                <para>processingInstruction() is called for each Processing Instruction Node.</para>
                <para>namespaceBinding() is called for each Namespace Node.</para>
                <para>atomicValue() is called for each atomic value.</para>
                <para>
                </para>
                <para>For a complete explanation of XQuery sequences, visit XQuery Data Model.</para>
                <para>
                </para>
                <para>See also W3C XQuery 1.0 and XPath 2.0 Data Model (XDM), QXmlSerializer, and QXmlResultItems.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.#ctor">
            <summary>
                <para>Constructs an abstract xml receiver.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.AtomicValue(System.Object)">
            <summary>
                <para>This callback is called when an atomic value appears in the sequence. The value is a simple data value. It is guaranteed to be valid.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.Attribute(QtXmlPatterns.QXmlName,QtCore.QStringRef)">
            <summary>
                <para>This callback is called when an attribute node appears in the sequence. name is the attribute name and the value string contains the attribute value.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.Characters(QtCore.QStringRef)">
            <summary>
                <para>This callback is called when a text node appears in the sequence. The value contains the text. Adjacent text nodes may not occur in the sequence, i.e., this callback must not be called twice in a row.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.Comment(System.String)">
            <summary>
                <para>This callback is called when a comment node appears in the sequence. The value is the comment text, which must not contain the string "--".</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.EndDocument">
            <summary>
                <para>This callback is called when the end of a document node appears in the sequence.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.EndElement">
            <summary>
                <para>This callback is called when the end of an element node appears in the sequence.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.EndOfSequence">
            <summary>
                <para>This callback is called once only, right after the sequence ends.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.NamespaceBinding(QtXmlPatterns.QXmlName)">
            <summary>
                <para>This callback is called when a namespace binding is in scope of an element. A namespace is defined by a URI. In the QXmlName name, the value of QXmlName::namespaceUri() is that URI. The value of QXmlName::prefix() is the prefix that the URI is bound to. The local name is insignificant and can be an arbitrary value.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.ProcessingInstruction(QtXmlPatterns.QXmlName,System.String)">
            <summary>
                <para>This callback is called when a processing instruction appears in the sequence. A processing instruction is used in an XML document to tell the application reading the document to perform some action. A typical example is to use a processing instruction to tell the application to use a particular XSLT stylesheet to process the document.</para>
                <para> &lt;?xml-stylesheet type="test/xsl" href="formatter.xsl"?&gt;</para>
                <para>target is the name of the processing instruction. Its prefix and namespace URI must both be empty. Its local name is the target. In the above example, the name is xml-stylesheet.</para>
                <para>The value specifies the action to be taken. Note that the value must not contain the string "?&gt;". In the above example, the value is type="test/xsl" href="formatter.xsl.</para>
                <para>Generally, use of processing instructions should be avoided, because they are not namespace aware and in many contexts are stripped out anyway. Processing instructions can often be replaced with elements from a custom namespace.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.StartDocument">
            <summary>
                <para>This callback is called when a document node appears in the sequence.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.StartElement(QtXmlPatterns.QXmlName)">
            <summary>
                <para>This callback is called when a new element node appears in the sequence. name is the valid name of the node element.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.StartOfSequence">
            <summary>
                <para>This callback is called once only, right before the sequence begins.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QAbstractXmlReceiver.Finalize">
            <summary>
                <para>Destroys the xml receiver.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.Global.QVersion">
            <summary>
                <para>Returns the version number of Qt at run-time as a string (for example, "4.1.2"). This may be a different version than the version the application was compiled against.</para>
                <para>See also QT_VERSION_STR.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.Global.Qrand">
            <summary>
                <para>Thread-safe version of the standard C++ rand() function.</para>
                <para>Returns a value between 0 and RAND_MAX (defined in &lt;cstdlib&gt; and &lt;stdlib.h&gt;), the next number in the current sequence of pseudo-random integers.</para>
                <para>Use qsrand() to initialize the pseudo-random number generator with a seed value.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also qsrand().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.Write(QtCore.QDataStream,System.Collections.Generic.List{System.String})">
            <summary>
                <para>Writes the given string list to the specified out stream.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.Read(QtCore.QDataStream,System.Collections.Generic.List{System.String})">
            <summary>
                <para>Reads a string list from the given in stream into the specified list.</para>
                <para>See also Serializing Qt Data Types.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QAcos(System.Double)">
            <summary>
                <para>Returns the arccosine of v as an angle in radians. Arccosine is the inverse operation of cosine.</para>
                <para>See also qAtan(), qAsin(), and qCos().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QAsin(System.Double)">
            <summary>
                <para>Returns the arcsine of v as an angle in radians. Arcsine is the inverse operation of sine.</para>
                <para>See also qSin(), qAtan(), and qAcos().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QAtan(System.Double)">
            <summary>
                <para>Returns the arctangent of v as an angle in radians. Arctangent is the inverse operation of tangent.</para>
                <para>See also qTan(), qAcos(), and qAsin().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QAtan2(System.Double,System.Double)">
            <summary>
                <para>Returns the arctangent of a point specified by the coordinates x and y. This function will return the angle and its direction.</para>
                <para>See also qAtan().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QCeil(System.Double)">
            <summary>
                <para>Return the ceiling of the value v.</para>
                <para>The ceiling is the smallest integer that is not less than v. For example, if v is 41.2, then the ceiling is 42.</para>
                <para>See also qFloor().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QCos(System.Double)">
            <summary>
                <para>Returns the cosine of an angle v in radians.</para>
                <para>See also qSin() and qTan().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QExp(System.Double)">
            <summary>
                <para>Returns the exponential function of e to the power of v.</para>
                <para>See also qLn().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QFloor(System.Double)">
            <summary>
                <para>Return the floor of the value v.</para>
                <para>The floor is the largest integer that is not greater than v. For example, if v is 41.2, then the floor is 41.</para>
                <para>See also qCeil().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QFuzzyCompare(System.Double,System.Double)">
            <summary>
                <para>Compares the floating point value p1 and p2 and returns true if they are considered equal, otherwise false.</para>
                <para>Note that comparing values where either p1 or p2 is 0.0 will not work. The solution to this is to compare against values greater than or equal to 1.0.</para>
                <para>         // Instead of comparing with 0.0</para>
                <para>                 qFuzzyCompare(0.0,1.0e-200); // This will return false</para>
                <para>         // Compare adding 1 to both values will fix the problem</para>
                <para>                 qFuzzyCompare(1 + 0.0, 1 + 1.0e-200); // This will return true</para>
                <para>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</para>
                <para>Note: This function is thread-safe.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QFuzzyCompare(System.Single,System.Single)">
            <summary>
                <para>Compares the floating point value p1 and p2 and returns true if they are considered equal, otherwise false.</para>
                <para>The two numbers are compared in a relative way, where the exactness is stronger the smaller the numbers are.</para>
                <para>Note: This function is thread-safe.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(QtCore.QBitArray)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(QtXmlPatterns.QSourceLocation)">
            <summary>
                <para>Computes a hash key for the QSourceLocation location.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Computes a hash key from the QXmlNodeModelIndex index, and returns it. This function would be used by QHash if you wanted to build a hash table for instances of QXmlNodeModelIndex.</para>
                <para>The hash is computed on QXmlNodeModelIndex::data(), QXmlNodeModelIndex::additionalData(), and QXmlNodeModelIndex::model(). This means the hash key can be used for node indexes from different node models.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Computes a hash key from the local name and the namespace URI in name. The prefix in name is not used in the computation.</para>
                <para>This function was introduced in Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(QtCore.QChar)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(QtCore.QByteArray)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.UInt32)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.Char)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.Byte)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.Int16)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(NativeLong)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.UInt16)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.Int64)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.UInt64)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.Int32)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(System.String)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QHash(NativeULong)">
            <summary>
                <para>Returns the hash value for the key.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QInstallMsgHandler(QtXmlPatterns.Global.ActionQtMsgTypeString)">
            <summary>
                <para>Installs a Qt message handler which has been defined previously. Returns a pointer to the previous message handler (which may be 0).</para>
                <para>The message handler is a function that prints out debug messages, warnings, critical and fatal error messages. The Qt library (debug mode) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. Qt built in release mode also contains such warnings unless QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during compilation. If you implement your own message handler, you get total control of these messages.</para>
                <para>The default message handler prints the message to the standard output under X11 or to the debugger under Windows. If it is a fatal message, the application aborts immediately.</para>
                <para>Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.</para>
                <para>To restore the message handler, call qInstallMsgHandler(0).</para>
                <para>Example:</para>
                <para> #include &lt;qapplication.h&gt;</para>
                <para> #include &lt;stdio.h&gt;</para>
                <para> #include &lt;stdlib.h&gt;</para>
                <para>
                </para>
                <para> void myMessageOutput(QtMsgType type, const char *msg)</para>
                <para> {</para>
                <para>     switch (type) {</para>
                <para>     case QtDebugMsg:</para>
                <para>         fprintf(stderr, "Debug: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtWarningMsg:</para>
                <para>         fprintf(stderr, "Warning: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtCriticalMsg:</para>
                <para>         fprintf(stderr, "Critical: %s\\n", msg);</para>
                <para>         break;</para>
                <para>     case QtFatalMsg:</para>
                <para>         fprintf(stderr, "Fatal: %s\\n", msg);</para>
                <para>         abort();</para>
                <para>     }</para>
                <para> }</para>
                <para>
                </para>
                <para> int main(int argc, char **argv)</para>
                <para> {</para>
                <para>     qInstallMsgHandler(myMessageOutput);</para>
                <para>     QApplication app(argc, argv);</para>
                <para>     ...</para>
                <para>     return app.exec();</para>
                <para> }</para>
                <para>See also qDebug(), qWarning(), qCritical(), qFatal(), QtMsgType, and Debugging Techniques.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QLn(System.Double)">
            <summary>
                <para>Returns the natural logarithm of v. Natural logarithm uses base e.</para>
                <para>See also qExp().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QPow(System.Double,System.Double)">
            <summary>
                <para>Returns the value of x raised to the power of y. That is, x is the base and y is the exponent.</para>
                <para>See also qSqrt().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QRound(System.Double)">
            <summary>
                <para>Rounds value to the nearest integer.</para>
                <para>Example:</para>
                <para> qreal valueA = 2.3;</para>
                <para> qreal valueB = 2.7;</para>
                <para>
                </para>
                <para> int roundedValueA = qRound(valueA);</para>
                <para> // roundedValueA = 2</para>
                <para> int roundedValueB = qRound(valueB);</para>
                <para> // roundedValueB = 3</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QRound64(System.Double)">
            <summary>
                <para>Rounds value to the nearest 64-bit integer.</para>
                <para>Example:</para>
                <para> qreal valueA = 42949672960.3;</para>
                <para> qreal valueB = 42949672960.7;</para>
                <para>
                </para>
                <para> int roundedValueA = qRound(valueA);</para>
                <para> // roundedValueA = 42949672960</para>
                <para> int roundedValueB = qRound(valueB);</para>
                <para> // roundedValueB = 42949672961</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QSin(System.Double)">
            <summary>
                <para>Returns the sine of the angle v in radians.</para>
                <para>See also qCos() and qTan().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QSqrt(System.Double)">
            <summary>
                <para>Returns the square root of v. This function returns a NaN if v is a negative number.</para>
                <para>See also qPow().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QTan(System.Double)">
            <summary>
                <para>Returns the tangent of an angle v in radians.</para>
                <para>See also qSin() and qCos().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.Qgetenv(System.String)">
            <summary>
                <para>Returns the value of the environment variable with name varName. To get the variable string, use QByteArray::constData().</para>
                <para>Note: qgetenv() was introduced because getenv() from the standard C library was deprecated in VC2005 (and later versions). qgetenv() uses the new replacement function in VC, and calls the standard C library's implementation on all other platforms.</para>
                <para>See also qputenv().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.Qputenv(System.String,QtCore.QByteArray)">
            <summary>
                <para>This function sets the value of the environment variable named varName. It will create the variable if it does not exist. It returns 0 if the variable could not be set.</para>
                <para>Note: qputenv() was introduced because putenv() from the standard C library was deprecated in VC2005 (and later versions). qputenv() uses the replacement function in VC, and calls the standard C library's implementation on all other platforms.</para>
                <para>See also qgetenv().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.Qsrand(System.UInt32)">
            <summary>
                <para>Thread-safe version of the standard C++ srand() function.</para>
                <para>Sets the argument seed to be used to generate a new random number sequence of pseudo random integers to be returned by qrand().</para>
                <para>The sequence of random numbers generated is deterministic per thread. For example, if two threads call qsrand(1) and subsequently calls qrand(), the threads will get the same random number sequence.</para>
                <para>This function was introduced in Qt 4.2.</para>
                <para>See also qrand().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.Global.QtTrId(System.String,System.Int32)">
            <summary>
                <para>The qtTrId function finds and returns a translated string.</para>
                <para>Returns a translated string identified by id. If no matching string is found, the id itself is returned. This should not happen under normal conditions.</para>
                <para>If n &gt;= 0, all occurrences of %n in the resulting string are replaced with a decimal representation of n. In addition, depending on n's value, the translation text may vary.</para>
                <para>Meta data and comments can be passed as documented for QObject::tr(). In addition, it is possible to supply a source string template like that:</para>
                <para>//% &lt;C string&gt;</para>
                <para>or</para>
                <para>/*% &lt;C string&gt; */</para>
                <para>Example:</para>
                <para>     //% "%n fooish bar(s) found.\\n"</para>
                <para>     //% "Do you want to continue?"</para>
                <para>     QString text = qtTrId("qtn_foo_bar", n);</para>
                <para>Creating QM files suitable for use with this function requires passing the -idbased option to the lrelease tool.</para>
                <para>Warning: This method is reentrant only if all translators are installed before calling this method. Installing or removing translators while performing translations is not supported. Doing so will probably result in crashes or other undesirable behavior.</para>
                <para>Note: This function is reentrant.</para>
                <para>This function was introduced in Qt 4.6.</para>
                <para>See also QObject::tr(), QCoreApplication::translate(), and Internationalization with Qt.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QSimpleXmlNodeModel">
            <summary>
            The QSimpleXmlNodeModel class is an implementation of QAbstractXmlNodeModel sufficient for many common cases.
            </summary>
            <remarks>
                <para>
                </para>
                <para>Subclassing QAbstractXmlNodeModel can be a significant task, because it requires implementing several, complex member functions. QSimpleXmlNodeModel provides default implementations of these member functions that are suitable for a wide range of node models.</para>
                <para>Subclasses of QSimpleXmlNodeModel must be thread-safe.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QSimpleXmlNodeModel.#ctor(QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Constructs a QSimpleXmlNodeModel for use with with the specified namePool.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QSimpleXmlNodeModel.NamePool">
            <summary>
                <para>Returns the name pool associated with this model. The implementation of name() will use this name pool to create names.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSimpleXmlNodeModel.BaseUri(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Reimplemented from QAbstractXmlNodeModel::baseUri().</para>
                <para>Returns the base URI for node. This is always the document URI.</para>
                <para>See also documentUri().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSimpleXmlNodeModel.ElementById(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Reimplemented from QAbstractXmlNodeModel::elementById().</para>
                <para>Always returns a default constructed QXmlNodeModelIndex instance, regardless of id.</para>
                <para>This effectively means the model has no elements that have an id.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSimpleXmlNodeModel.NamespaceBindings(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Reimplemented from QAbstractXmlNodeModel::namespaceBindings().</para>
                <para>Always returns an empty QVector. This signals that no namespace bindings are in scope for node.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSimpleXmlNodeModel.NodesByIdref(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Reimplemented from QAbstractXmlNodeModel::nodesByIdref().</para>
                <para>Always returns an empty vector, regardless of idref.</para>
                <para>This effectively means the model has no elements or attributes of type IDREF.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSimpleXmlNodeModel.StringValue(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Reimplemented from QAbstractXmlNodeModel::stringValue().</para>
                <para>If node is an element or attribute, typedValue() is called, and the return value converted to a string, as per XQuery's rules.</para>
                <para>If node is another type of node, the empty string is returned.</para>
                <para>If this function is overridden for comments or processing instructions, it is important to remember to call it (for elements and attributes having values not of type xs:string) to ensure that the values are formatted according to XQuery.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSimpleXmlNodeModel.Finalize">
            <summary>
                <para>Destructor.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QSourceLocation">
            <summary>
            The QSourceLocation class identifies a location in a resource by URI, line, and column.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QSourceLocation is a simple value based class that has three properties, uri(), line(), and column(), that, taken together, identify a certain point in a resource, e.g., a file or an in-memory document.</para>
                <para>line() and column() refer to character counts (not byte counts), and they both start from 1, as opposed to 0.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QSourceLocation.#ctor">
            <summary>
                <para>Construct a QSourceLocation that doesn't identify anything at all.</para>
                <para>For a default constructed QSourceLocation(), isNull() returns true.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSourceLocation.#ctor(QtXmlPatterns.QSourceLocation)">
            <summary>
                <para>Constructs a QSourceLocation that is a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSourceLocation.#ctor(QtCore.QUrl,System.Int32,System.Int32)">
            <summary>
                <para>Constructs a QSourceLocation with URI u, line l and column c.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QSourceLocation.Column">
            <summary>
                <para>Returns the current column number. The column number refers to the count of characters, not bytes. The first column is column 1, not 0. The default value is -1, indicating the column number is unknown.</para>
                <para>Sets the column number to newColumn. 0 is an invalid column number. The first column number is 1.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QSourceLocation.Line">
            <summary>
                <para>Returns the current line number. The first line number is 1, not 0. The default value is -1, indicating the line number is unknown.</para>
                <para>Sets the line number to newLine. 0 is an invalid line number. The first line number is 1.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QSourceLocation.Uri">
            <summary>
                <para>Returns the resource that this QSourceLocation refers to. For example, the resource could be a file in the local file system, if the URI scheme is file.</para>
                <para>Sets the URI to newUri.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QSourceLocation.IsNull">
            <summary>
                <para>Returns true if this QSourceLocation doesn't identify anything.</para>
                <para>For a default constructed QSourceLocation, this function returns true. The same applies for any other QSourceLocation whose uri() is invalid.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSourceLocation.Finalize">
            <summary>
                <para>Destructor.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSourceLocation.op_Inequality(QtXmlPatterns.QSourceLocation,QtXmlPatterns.QSourceLocation)">
            <summary>
                <para>Returns the opposite of applying operator==() for this QXmlName and other.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QSourceLocation.op_Equality(QtXmlPatterns.QSourceLocation,QtXmlPatterns.QSourceLocation)">
            <summary>
                <para>Returns true if this QSourceLocation is identical to other.</para>
                <para>Two QSourceLocation instances are equal if their uri(), line() and column() are equal.</para>
                <para>QSourceLocation instances for which isNull() returns true are considered equal.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlFormatter">
            <summary>
            The QXmlFormatter class is an implementation of QXmlSerializer for transforming XQuery output into formatted XML.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QXmlFormatter is a subclass of QXmlSerializer that formats the XML output to make it easier for humans to read.</para>
                <para>QXmlSerializer outputs XML without adding unnecessary whitespace. In particular, it does not add newlines and indentation. To make the XML output easier to read, QXmlFormatter adds newlines and indentation by adding, removing, and modifying sequence nodes that only consist of whitespace. It also modifies whitespace in other places where it is not significant; e.g., between attributes and in the document prologue.</para>
                <para>For example, where the base class QXmlSerializer would output this:</para>
                <para> &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;p&gt;Some Text&lt;/p&gt;&lt;/a&gt;</para>
                <para>QXmlFormatter outputs this:</para>
                <para> &lt;a&gt;</para>
                <para>    &lt;b/&gt;</para>
                <para>    &lt;c/&gt;</para>
                <para>    &lt;p&gt;Some Text&lt;/p&gt;</para>
                <para> &lt;/a&gt;</para>
                <para>If you just want to serialize your XML in a human-readable format, use QXmlFormatter as it is. The default indentation level is 4 spaces, but you can set your own indentation value setIndentationDepth().</para>
                <para>The newlines and indentation added by QXmlFormatter are suitable for common formats, such as XHTML, SVG, or Docbook, where whitespace is not significant. However, if your XML will be used as input where whitespace is significant, then you must write your own subclass of QXmlSerializer or QAbstractXmlReceiver.</para>
                <para>Note that using QXmlFormatter instead of QXmlSerializer will increase computational overhead and document storage size due to the insertion of whitespace.</para>
                <para>Note also that the indentation style used by QXmlFormatter remains loosely defined and may change in future versions of Qt. If a specific indentation style is required then either use the base class QXmlSerializer directly, or write your own subclass of QXmlSerializer or QAbstractXmlReceiver. Alternatively, you can subclass QXmlFormatter and reimplement the callbacks there.</para>
                <para> QXmlQuery query;</para>
                <para> query.setQuery("doc('index.html')/html/body/p[1]");</para>
                <para>
                </para>
                <para> QXmlFormatter formatter(query, myOutputDevice);</para>
                <para> formatter.setIndentationDepth(2);</para>
                <para> query.evaluateTo(&amp;formatter);</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.#ctor(QtXmlPatterns.QXmlQuery,QtCore.QIODevice)">
            <summary>
                <para>Constructs a formatter that uses the name pool and message handler in query, and writes the result to outputDevice as formatted XML.</para>
                <para>outputDevice is passed directly to QXmlSerializer's constructor.</para>
                <para>See also QXmlSerializer.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlFormatter.IndentationDepth">
            <summary>
                <para>Returns the number of spaces QXmlFormatter will output for each indentation level. The default is four.</para>
                <para>Sets depth to be the number of spaces QXmlFormatter will output for level of indentation. The default is four.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.AtomicValue(System.Object)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::atomicValue().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.Attribute(QtXmlPatterns.QXmlName,QtCore.QStringRef)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::attribute().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.Characters(QtCore.QStringRef)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::characters().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.Comment(System.String)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::comment().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.EndDocument">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::endDocument().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.EndElement">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::endElement().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.EndOfSequence">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::endOfSequence().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.ProcessingInstruction(QtXmlPatterns.QXmlName,System.String)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::processingInstruction().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.StartDocument">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::startDocument().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.StartElement(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::startElement().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlFormatter.StartOfSequence">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::startOfSequence().</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlItem">
            <summary>
            The QXmlItem class contains either an XML node or an atomic value.
            </summary>
            <remarks>
                <para>
                </para>
                <para>In XQuery, all expressions evaluate to a sequence of items, where each item is either an XML node or an atomic value. The query in the following snippet evaluates to sequence of five items.</para>
                <para> &lt;aNode/&gt;,</para>
                <para> xs:base64Binary("FFFF"),</para>
                <para> current-date(),</para>
                <para> 3e3, (: A floating point value :)</para>
                <para> attribute {"name"} {()}</para>
                <para>The five items are: An element, an atomic value (binary data encoded in base64), a date, a float, and an attribute.</para>
                <para>QXmlItem is the class that represents these XQuery items in the QtXmlPatterns API. A non-null instance of QXmlItem is either a node or an atomic value. Calling isNode() or isAtomicValue() tells you which it is. Atomic values are represented elsewhere in the Qt API as instances of QVariant, and an instance of QXmlItem that represents an atomic value can be converted to a QVariant by calling toAtomicValue(). A QXmlItem that wraps a node is represented elsewhere as an instance of QXmlNodeModelIndex. A node QXmlItem can be converted to a QXmlNodeModelIndex by calling toNodeModelIndex().</para>
                <para>A default constructed QXmlItem instance is neither a node nor an atomic value. It is considered null, in which case isNull() returns true.</para>
                <para>An instance of QXmlItem will be left dangling if the XML node model it refers to is deleted, if it is a QXmlNodeModelIndex.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlItem.#ctor">
            <summary>
                <para>Constructs a null QXmlItem that is neither a node nor an atomic value. isNull() returns true for a default constructed instance.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlItem.#ctor(QtXmlPatterns.QXmlItem)">
            <summary>
                <para>The copy constructor constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlItem.#ctor(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Constructs a node QXmlItem that is a copy of node.</para>
                <para>See also isNode().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlItem.#ctor(System.Object)">
            <summary>
                <para>Constructs an atomic value QXmlItem with atomicValue.</para>
                <para>See also isAtomicValue().</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlItem.IsAtomicValue">
            <summary>
                <para>Returns true if this item is an atomic value. Returns false if it is a node or null.</para>
                <para>See also isNull() and isNode().</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlItem.IsNode">
            <summary>
                <para>Returns true if this item is a Node. Returns false if it is an atomic value or null.</para>
                <para>See also isNull() and isAtomicValue().</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlItem.IsNull">
            <summary>
                <para>Returns true if this QXmlItem is neither a node nor an atomic value. Default constructed instances of QXmlItem are null.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlItem.ToAtomicValue">
            <summary>
                <para>If this QXmlItem represents an atomic value, it is converted to an appropriate QVariant and returned. If this QXmlItem is not an atomic value, the return value is a default constructed QVariant. You can call isAtomicValue() to test whether the item is an atomic value.</para>
                <para>See also isAtomicValue().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlItem.ToNodeModelIndex">
            <summary>
                <para>If this QXmlItem represents a node, it returns the item as a QXmlNodeModelIndex. If this QXmlItem is not a node, the return value is undefined. You can call isNode() to test whether the item is a node.</para>
                <para>See also isNode().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlItem.Finalize">
            <summary>
                <para>Destructor.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlName">
            <summary>
            The QXmlName class represents the name of an XML node, in an efficient, namespace-aware way.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QXmlName represents the name of an XML node in a way that is both efficient and safe for comparing names. Normally, an XML node represents an XML element or attribute, but QXmlName can also represent the names of other kinds of nodes, e.g., QAbstractXmlReceiver::processingInstruction() and QAbstractXmlReceiver::namespaceBinding().</para>
                <para>The name of an XML node has three components: The namespace URI, the local name, and the prefix. To see what these refer to in XML, consider the following snippet.</para>
                <para> &lt;book xmlns:dc='http://purl.org/dc/elements/1.1'</para>
                <para>       xmlns='http://example.com/MyDefault'&gt;</para>
                <para>     &lt;dc:title&gt;Mobey Dick&lt;/dc:title&gt; ...</para>
                <para> &lt;/book&gt;</para>
                <para>For the element named book, localName() returns book, namespaceUri() returns http://example.com/MyDefault, and prefix() returns an empty string. For the element named title, localName() returns title, namespaceUri() returns http://purl.org/dc/elements/1.1, and prefix() returns dc.</para>
                <para>To ensure that operations with QXmlName are efficient, e.g., copying names and comparing them, each instance of QXmlName is associated with a name pool, which must be specified at QXmlName construction time. The three components of the QXmlName, i.e., the namespace URI, the local name, and the prefix, are stored in the name pool mapped to identifiers so they can be shared. For this reason, the only way to create a valid instance of QXmlName is to use the class constructor, where the name pool, local name, namespace URI, and prefix must all be specified.</para>
                <para>Note that QXmlName's default constructor constructs a null instance. It is typically used for allocating unused entries in collections of QXmlName.</para>
                <para>A side effect of associating each instance of QXmlName with a name pool is that each instance of QXmlName is tied to the QXmlNamePool with which it was created. However, the QXmlName class does not keep track of the name pool, so all the accessor functions, e.g., namespaceUri(), prefix(), localName(), and toClarkName() require that the correct name pool be passed to them. Failure to provide the correct name pool to these accessor functions results in undefined behavior.</para>
                <para>Note that a name pool is not an XML namespace. One name pool can represent instances of QXmlName from different XML namespaces, and the instances of QXmlName from one XML namespace can be distributed over multiple name pools.</para>
                <para>
                </para>
                <para>Comparing QXmlNames</para>
                <para>To determine what a QXmlName refers to, the namespace URI and the local name are used. The prefix is not used because the prefix is simply a shorthand name for use in place of the normally much longer namespace URI. Nor is the prefix used in name comparisons. For example, the following two element nodes represent the same element and compare equal.</para>
                <para> &lt;svg xmlns="http://www.w3.org/2000/svg"/&gt;</para>
                <para> &lt;x:svg xmlns:x="http://www.w3.org/2000/svg"/&gt;</para>
                <para>Although the second name has the prefix x, the two names compare equal as instances of QXmlName, because the prefix is not used in the comparison.</para>
                <para>A local name can never be an empty string, although the prefix and namespace URI can. If the prefix is not empty, the namespace URI cannot be empty. Local names and prefixes must be valid NCNames, e.g., abc.def or abc123.</para>
                <para>QXmlName represents what is sometimes called an expanded QName, or simply a QName.</para>
                <para>
                </para>
                <para>See also Namespaces in XML 1.0 (Second Edition), [4] NCName.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.#ctor">
            <summary>
                <para>Constructs an uninitialized QXmlName. To build a valid QXmlName, you normally use the other constructor, which takes a name pool, namespace URI, local name, and prefix as parameters. But you can also use this constructor to build a null QXmlName and then assign an existing QXmlName to it.</para>
                <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.#ctor(QtXmlPatterns.QXmlNamePool,System.String,System.String,System.String)">
            <summary>
                <para>Constructs a QXmlName instance that inserts localName, namespaceURI and prefix into namePool if they aren't already there. The accessor functions namespaceUri(), prefix(), localName(), and toClarkName() must be passed the namePool used here, so the namePool must remain in scope while the accessor functions might be used. However, two instances can be compared with == or != and copied without the namePool.</para>
                <para>The user guarantees that the string components are valid for a QName. In particular, the local name, and the prefix (if present), must be valid NCNames. The function isNCName() can be used to test validity of these names. The namespace URI should be an absolute URI. QUrl::isRelative() can be used to test whether the namespace URI is relative or absolute. Finally, providing a prefix is not valid when no namespace URI is provided.</para>
                <para>namePool is not copied. Nor is the reference to it retained in this instance. This constructor inserts the three strings into namePool.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlName.IsNull">
            <summary>
                <para>Returns true if this QXmlName is not initialized with a valid combination of namespace URI, local name, and prefix.</para>
                <para>A valid local name is always required. The prefix and namespace URI can be empty, but if the prefix is not empty, the namespace URI must not be empty. Local names and prefixes must be valid NCNames, e.g., abc.def or abc123.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.FromClarkName(System.String,QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Converts clarkName into a QXmlName, inserts into namePool, and returns it.</para>
                <para>A clark name is a way to present a full QName with only one string, where the namespace cannot contain braces. Here are a couple of examples:</para>
                <para>
                </para>
                <para>Clark NameDescription</para>
                <para>html	The local name html, in no namespace</para>
                <para>http://www.w3.org/1999/xhtmlhtml	The local name html, in the XHTML namespace</para>
                <para>http://www.w3.org/1999/xhtmlmy:html	The local name html, in the XHTML namespace, with the prefix my</para>
                <para>
                </para>
                <para>If the namespace contains braces, the returned value is either invalid or has undefined content.</para>
                <para>If clarkName is an invalid name, a default constructed QXmlName is returned.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also toClarkName().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.IsNCName(System.String)">
            <summary>
                <para>Returns true if candidate is an NCName. An NCName is a string that can be used as a name in XML and XQuery, e.g., the prefix or local name in an element or attribute, or the name of a variable.</para>
                <para>See also Namespaces in XML 1.0 (Second Edition), [4] NCName.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.LocalName(QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Returns the local name.</para>
                <para>Note that for efficiency, the local name string is not stored in the QXmlName but in the QXmlNamePool that was passed to the constructor. Hence, that same namePool must be passed to this function, so it can be used for looking up the local name.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.NamespaceUri(QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Returns the namespace URI.</para>
                <para>Note that for efficiency, the namespace URI string is not stored in the QXmlName but in the QXmlNamePool that was passed to the constructor. Hence, that same namePool must be passed to this function, so it can be used for looking up the namespace URI.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.Prefix(QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Returns the prefix.</para>
                <para>Note that for efficiency, the prefix string is not stored in the QXmlName but in the QXmlNamePool that was passed to the constructor. Hence, that same namePool must be passed to this function, so it can be used for looking up the prefix.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.ToClarkName(QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Returns this QXmlName formatted as a Clark Name. For example, if the local name is html, the prefix is x, and the namespace URI is http://www.w3.org/1999/xhtml/, then the Clark Name returned is:</para>
                <para> {http://www.w3.org/1999/xhtml/}x:html.</para>
                <para>If the local name is MyWidget and the namespace is empty, the Clark Name returned is:</para>
                <para> MyWidget</para>
                <para>Note that for efficiency, the namespace URI, local name, and prefix strings are not stored in the QXmlName but in the QXmlNamePool that was passed to the constructor. Hence, that same namePool must be passed to this function, so it can be used for looking up the three string components.</para>
                <para>This function can be useful for debugging.</para>
                <para>See also XML Namespaces, James Clark and fromClarkName().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.op_Inequality(QtXmlPatterns.QXmlName,QtXmlPatterns.QXmlName)">
            <summary>
                <para>Returns true if this QXmlName is not equal to other; otherwise false. Two QXmlNames are equal if their namespace URIs are the same and their local names are the same. They are not equal if either their namespace URIs differ or their local names differ. Their prefixes are ignored.</para>
                <para>Note that it is meaningless to compare two instances of QXmlName that were created with different name pools, but the attempt is not detected and the behavior is undefined.</para>
                <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlName.op_Equality(QtXmlPatterns.QXmlName,QtXmlPatterns.QXmlName)">
            <summary>
                <para>Returns true if this QXmlName is equal to other; otherwise false. Two QXmlNames are equal if their namespace URIs are the same and their local names are the same. The prefixes are ignored.</para>
                <para>Note that it is meaningless to compare two instances of QXmlName that were created with different name pools, but the attempt is not detected and the behavior is undefined.</para>
                <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlNamePool">
            <summary>
            The QXmlNamePool class is a table of shared strings referenced by instances of QXmlName.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QXmlNamePool is used to optimize operations on instances of QXmlName. An instance of QXmlName represents an XML name in a way that allows the XML name to be compared and passed around efficiently. The efficiency is achieved by storing the strings comprising the XML names in an instance of QXmlNamePool, where they are mapped to binary identifiers, which are then packed into a key which is stored in the QXmlName.</para>
                <para>This means that each instance of QXmlName is tied to the name pool it was created with, and that name pool should be kept in scope and used to create all instances of QXmlName that might be compared. Note also that the name pool is required if you must reconstitute the QXmlName as text, or if you must access any of its component strings, so although instances of QXmlName can be compared without reference to a name pool, the name pool must be kept in scope if the name's strings must be accessed later.</para>
                <para>
                </para>
                <para>See also QXmlName and QXmlQuery::namePool().</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlNamePool.#ctor">
            <summary>
                <para>Constructs an empty name pool.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlNamePool.#ctor(QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Constructs a copy of the other name pool.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlNamePool.Finalize">
            <summary>
                <para>Destroys the name pool. Instances of QXmlName constructed with this name pool can still be compared after this destructor is called, but their text strings cannot be accessed.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlNodeModelIndex">
            <summary>
            The QXmlNodeModelIndex class identifies a node in an XML node model subclassed from QAbstractXmlNodeModel.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QXmlNodeModelIndex is an index into an XML node model. It contains:</para>
                <para>
                </para>
                <para>A pointer to an XML node model, which is returned by model(), and</para>
                <para>Some data, which is returned by data(), internalPointer(), and additionalData().</para>
                <para>
                </para>
                <para>Because QXmlNodeModelIndex is intentionally a simple class, it doesn't have member functions for accessing the properties of nodes. For example, it doesn't have functions for getting a node's name or its list of attributes or child nodes. If you find that you need to retrieve this kind of information from your query results, there are two ways to proceed.</para>
                <para>
                </para>
                <para>Send the output of your XQuery to an XML receiver, or</para>
                <para>Let your XQuery do all the work to produce the desired result.</para>
                <para>
                </para>
                <para>The second case is explained by example. Suppose you want to populate a list widget with the values of certain attributes from a set of result elements. You could write an XQuery to return the set of elements, and then you would write the code to iterate over the result elements, get their attributes, and extract the desired string values. But the simpler way is to just augment your XQuery to finding the desired attribute values. Then all you have to do is evaluate the XQuery using the version of QXmlQuery::evaluateTo() that populates a QStringList, which you can send directly to your widget.</para>
                <para>QXmlNodeModelIndex doesn't impose any restrictions on the data value an QXmlNodeModelIndex should contain. The meaning of the data left to the associated node model. Because QXmlNodeModelIndex depends on a particular subclass of QAbstractXmlNodeModel for its existence, the only way you can create an instance of QXmlNodeModelIndex is by asking the node model to create one for you with QAbstractXmlNodeModel::createIndex(). Since that function is protected, it is usually a good idea to write a public function that creates a QXmlNodeModelIndex from arguments that are appropriate for your particular node model.</para>
                <para>A default constructed node index is said to be null, i.e., isNull() returns true.</para>
                <para>QXmlNodeModelIndex and QAbstractXmlNodeModel follow the same design pattern used for QModelIndex and QAbstractItemModel.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlNodeModelIndex.#ctor">
            <summary>
                <para>Default constructor. Creates an item that is null.</para>
                <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlNodeModelIndex.#ctor(QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Standard copy constructor. Creates a QXmlNodeModelIndex instance that is a copy of other.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlNodeModelIndex.DocumentOrder">
            <summary>
                <para>Identifies the specific node comparison operator that should be used.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.DocumentOrder.Follows">
            <summary>
                <para>Signifies the \\&gt;\\&gt; operator. Test whether the first operand follows the second in the document.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.DocumentOrder.Is">
            <summary>
                <para>Signifies the is operator. Test whether two nodes have the same node identity.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.DocumentOrder.Precedes">
            <summary>
                <para>Signifies the \\&lt;\\&lt; operator. Test whether the first operand precedes the second in the document.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlNodeModelIndex.NodeKind">
            <summary>
                <para>Identifies a kind of node.</para>
                <para>Note that the optional XML declaration at very beginning of the XML document is not a processing instruction</para>
                <para>See also QAbstractXmlNodeModel::kind().</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.NodeKind.Attribute">
            <summary>
                <para>Identifies an attribute node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.NodeKind.Comment">
            <summary>
                <para>Identifies a comment node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.NodeKind.Document">
            <summary>
                <para>Identifies a document node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.NodeKind.Element">
            <summary>
                <para>Identifies an element node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.NodeKind.Namespace">
            <summary>
                <para>Identifies a namespace node</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.NodeKind.ProcessingInstruction">
            <summary>
                <para>Identifies a processing instruction.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlNodeModelIndex.NodeKind.Text">
            <summary>
                <para>Identifies a text node</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlNodeModelIndex.AdditionalData">
            <summary>
                <para>Returns the second data value. The node index holds two data values. data() returns the first one.</para>
                <para>See also data().</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlNodeModelIndex.Data">
            <summary>
                <para>Returns the first data value. The node index holds two data values. additionalData() returns the second one.</para>
                <para>See also additionalData().</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlNodeModelIndex.IsNull">
            <summary>
                <para>Returns true if this QXmlNodeModelIndex is a default constructed value, otherwise false.</para>
                <para>A null QXmlNodeModelIndex doesn't represent any node and cannot be used in conjunction with QAbstractXmlNodeModel.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlNodeModelIndex.Model">
            <summary>
                <para>Returns the QAbstractXmlNodeModel that this node index refers to. QXmlNodeModelIndex does not own QAbstractXmlNodeModel and does not keep track of its lifetime, so this pointer will dangle if the QAbstractXmlNodeModel is deallocated first.</para>
                <para>There is no setter for the node model because instances of QXmlNodeModelIndex instances are only created with QAbstractXmlNodeModel::createIndex().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlNodeModelIndex.op_Inequality(QtXmlPatterns.QXmlNodeModelIndex,QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns true if other is the same node as this.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlNodeModelIndex.op_Equality(QtXmlPatterns.QXmlNodeModelIndex,QtXmlPatterns.QXmlNodeModelIndex)">
            <summary>
                <para>Returns true if this node is the same as other. This operator does not compare values, children, or names of nodes. It compares node identities, i.e., whether two nodes are from the same document and are found at the exact same place.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlQuery">
            <summary>
            The QXmlQuery class performs XQueries on XML data, or on non-XML data modeled to look like XML.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QXmlQuery class compiles and executes queries written in the XQuery language. QXmlQuery is typically used to query XML data, but it can also query non-XML data that has been modeled to look like XML.</para>
                <para>Using QXmlQuery to query XML data, as in the snippet below, is simple because it can use the built-in XML data model as its delegate to the underlying query engine for traversing the data. The built-in data model is specified in XQuery 1.0 and XPath 2.0 Data Model.</para>
                <para> QXmlQuery query;</para>
                <para> query.setQuery("doc('index.html')/html/body/p[1]");</para>
                <para>
                </para>
                <para> QXmlSerializer serializer(query, myOutputDevice);</para>
                <para> query.evaluateTo(&amp;serializer);</para>
                <para>The example uses QXmlQuery to match the first paragraph of an XML document and then output the result to a device as XML.</para>
                <para>Using QXmlQuery to query non-XML data requires writing a subclass of QAbstractXmlNodeModel to use as a replacement for the built-in XML data model. The custom data model will be able to traverse the non-XML data as required by the QAbstractXmlNodeModel interface. An instance of this custom data model then becomes the delegate used by the query engine to traverse the non-XML data. For an example of how to use QXmlQuery to query non-XML data, see the documentation for QAbstractXmlNodeModel.</para>
                <para>
                </para>
                <para>Running XQueries</para>
                <para>To run a query set up with QXmlQuery, call one of the evaluation functions.</para>
                <para>
                </para>
                <para>evaluateTo(QAbstractXmlReceiver *) is called with a pointer to an XML receiver, which receives the query results as a sequence of callbacks. The receiver callback class is like the callback class used for translating the output of a SAX parser. QXmlSerializer, for example, is a receiver callback class for translating the sequence of callbacks for output as unformatted XML text.</para>
                <para>
                </para>
                <para>
                </para>
                <para>evaluateTo(QXmlResultItems *) is called with a pointer to an iterator for an empty sequence of query result items. The Java-like iterator allows the query results to be accessed sequentially.</para>
                <para>
                </para>
                <para>
                </para>
                <para>evaluateTo(QStringList *) is like evaluateTo(QXmlResultItems *), but the query must evaluate to a sequence of strings.</para>
                <para>
                </para>
                <para>
                </para>
                <para>Running XPath Expressions</para>
                <para>The XPath language is a subset of the XQuery language, so running an XPath expression is the same as running an XQuery query. Pass the XPath expression to QXmlQuery using setQuery().</para>
                <para>
                </para>
                <para>Running XSLT stylesheets</para>
                <para>Running an XSLT stylesheet is like running an XQuery, except that when you construct your QXmlQuery, you must pass QXmlQuery::XSLT20 to tell QXmlQuery to interpret whatever it gets from setQuery() as an XSLT stylesheet instead of as an XQuery. You must also set the input document by calling setFocus().</para>
                <para>     QXmlQuery query(QXmlQuery::XSLT20);</para>
                <para>     query.setFocus(QUrl("myInput.xml"));</para>
                <para>     query.setQuery(QUrl("myStylesheet.xsl"));</para>
                <para>     query.evaluateTo(out);</para>
                <para>Note: Currently, setFocus() must be called before setQuery() when using XSLT.</para>
                <para>Another way to run an XSLT stylesheet is to use the xmlpatterns command line utility.</para>
                <para> xmlpatterns myStylesheet.xsl myInput.xml</para>
                <para>Note: For the current release, XSLT support should be considered experimental. See section XSLT conformance for details.</para>
                <para>Stylesheet parameters are bound using bindVariable().</para>
                <para>
                </para>
                <para>Binding A Query To A Starting Node</para>
                <para>When a query is run on XML data, as in the snippet above, the doc() function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the bindVariable() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the XQuery text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for QAbstractXmlNodeModel.</para>
                <para>
                </para>
                <para>Reentrancy and Thread-Safety</para>
                <para>QXmlQuery is reentrant but not thread-safe. It is safe to use the QxmlQuery copy constructor to create a copy of a query and run the same query multiple times. Behind the scenes, QXmlQuery will reuse resources such as opened files and compiled queries to the extent possible. But it is not safe to use the same instance of QXmlQuery in multiple threads.</para>
                <para>
                </para>
                <para>Error Handling</para>
                <para>Errors can occur during query evaluation. Examples include type errors and file loading errors. When an error occurs:</para>
                <para>
                </para>
                <para>The error message is sent to the messageHandler().</para>
                <para>QXmlResultItems::hasError() will return true, or evaluateTo() will return false;</para>
                <para>The results of the evaluation are undefined.</para>
                <para>
                </para>
                <para>
                </para>
                <para>Resource Management</para>
                <para>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</para>
                <para>When setQuery() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of QXmlQuery for each query text.</para>
                <para>Once a document has been parsed, its internal representation is maintained in the QXmlQuery instance and shared among multiple QXmlQuery instances.</para>
                <para>An instance of QCoreApplication must exist before QXmlQuery can be used.</para>
                <para>
                </para>
                <para>Event Handling</para>
                <para>When QXmlQuery accesses resources (e.g., calling fn:doc() to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when QXmlQuery accesses resources, create your QXmlQuery instance in a separate thread.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.#ctor">
            <summary>
                <para>Constructs an invalid, empty query that cannot be used until setQuery() is called.</para>
                <para>Note: This constructor must not be used if you intend to use this QXmlQuery to process XSL-T stylesheets. The other constructor must be used in that case.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.#ctor(QtXmlPatterns.QXmlQuery)">
            <summary>
                <para>Constructs a QXmlQuery that is a copy of other. The new instance will share resources with the existing query to the extent possible.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.#ctor(QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Constructs a query that will use np as its name pool. The query cannot be evaluated until setQuery() has been called.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.#ctor(QtXmlPatterns.QXmlQuery.QueryLanguage)">
            <summary>
                <para>Constructs a query that will be used to run Xqueries or XSL-T stylesheets, depending on the value of queryLanguage. It will use np as its name pool.</para>
                <para>Note: If your QXmlQuery will process XSL-T stylesheets, this constructor must be used. The default constructor can only create instances of QXmlQuery for running XQueries.</para>
                <para>Note: The XSL-T support in this release is considered experimental. See the XSLT conformance for details.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also queryLanguage().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.#ctor(QtXmlPatterns.QXmlQuery.QueryLanguage,QtXmlPatterns.QXmlNamePool)">
            <summary>
                <para>Constructs a query that will be used to run Xqueries or XSL-T stylesheets, depending on the value of queryLanguage. It will use np as its name pool.</para>
                <para>Note: If your QXmlQuery will process XSL-T stylesheets, this constructor must be used. The default constructor can only create instances of QXmlQuery for running XQueries.</para>
                <para>Note: The XSL-T support in this release is considered experimental. See the XSLT conformance for details.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also queryLanguage().</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlQuery.QueryLanguage">
            <summary>
                <para>Specifies whether you want QXmlQuery to interpret the input to setQuery() as an XQuery or as an XSLT stylesheet.</para>
                <para>This enum was introduced or modified in Qt 4.5.</para>
                <para>See also setQuery().</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlQuery.QueryLanguage.XQuery10">
            <summary>
                <para>XQuery 1.0.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QXmlQuery.QueryLanguage.XSLT20">
            <summary>
                <para>XSLT 2.0 The selector, the restricted XPath pattern found in W3C XML Schema 1.1 for uniqueness contraints. Apart from restricting the syntax, the type check stage for the expression assumes a sequence of nodes to be the focus. The field, the restricted XPath pattern found in W3C XML Schema 1.1 for uniqueness contraints. Apart from restricting the syntax, the type check stage for the expression assumes a sequence of nodes to be the focus. Signifies XPath 2.0. Has no effect in the public API, it's used internally. As With XmlSchema11IdentityConstraintSelector and XmlSchema11IdentityConstraintField, the type check stage for the expression assumes a sequence of nodes to be the focus.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlQuery.InitialTemplateName">
            <summary>
                <para>Returns the name of the XSL-T stylesheet template that the processor will call first when running an XSL-T stylesheet. This function only applies when using QXmlQuery to process XSL-T stylesheets. By default, no initial template is set. In that case, a default constructed QXmlName is returned.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>Sets the name of the initial template. The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</para>
                <para>This function only applies when using QXmlQuery to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling setQuery().</para>
                <para>If the stylesheet has no template named name, the processor will use the standard order of template invocation.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlQuery.MessageHandler">
            <summary>
                <para>Returns the message handler that handles compile and runtime messages for this QXmlQuery.</para>
                <para>Changes the message handler for this QXmlQuery to aMessageHandler. The query sends all compile and runtime messages to this message handler. QXmlQuery does not take ownership of aMessageHandler.</para>
                <para>Normally, the default message handler is sufficient. It writes compile and runtime messages to stderr. The default message handler includes color codes if stderr can render colors.</para>
                <para>Note that changing the message handler after the query has been compiled has no effect, i.e. the query uses the same message handler at runtime that it uses at compile time.</para>
                <para>When QXmlQuery calls QAbstractMessageHandler::message(), the arguments are as follows:</para>
                <para>
                </para>
                <para>message() argumentSemantics</para>
                <para>QtMsgType type	Only QtWarningMsg and QtFatalMsg are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</para>
                <para>const QString &amp; description	An XHTML document which is the actual message. It is translated into the current language.</para>
                <para>const QUrl &amp;identifier	Identifies the error with a URI, where the fragment is the error code, and the rest of the URI is the error namespace.</para>
                <para>const QSourceLocation &amp; sourceLocation	Identifies where the error occurred.</para>
                <para>
                </para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlQuery.NetworkAccessManager">
            <summary>
                <para>Returns the network manager, or 0 if it has not been set.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>Sets the network manager to newManager. QXmlQuery does not take ownership of newManager.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlQuery.UriResolver">
            <summary>
                <para>Returns the query's URI resolver. If no URI resolver has been set, QtXmlPatterns will use the URIs in queries as they are.</para>
                <para>The URI resolver provides a level of abstraction, or polymorphic URIs. A resolver can rewrite logical URIs to physical ones, or it can translate obsolete or invalid URIs to valid ones.</para>
                <para>QtXmlPatterns calls the URI resolver for all URIs it encounters, except for namespaces. Specifically, all builtin functions that deal with URIs (fn:doc(), and fn:doc-available()).</para>
                <para>In the case of fn:doc(), the absolute URI is the base URI in the static context (which most likely is the location of the query). Rather than use the URI the user specified, the return value of QAbstractUriResolver::resolve() will be used.</para>
                <para>When QtXmlPatterns calls QAbstractUriResolver::resolve() the absolute URI is the URI mandated by the XQuery language, and the relative URI is the URI specified by the user.</para>
                <para>Sets the URI resolver to resolver. QXmlQuery does not take ownership of resolver.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlQuery.IsValid">
            <summary>
                <para>Returns true if this query is valid. Examples of invalid queries are ones that contain syntax errors or that have not had setQuery() called for them yet.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlQuery.NamePool">
            <summary>
                <para>Returns the name pool used by this QXmlQuery for constructing names. There is no setter for the name pool, because mixing name pools causes errors due to name confusion.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlQuery.queryLanguage">
            <summary>
                <para>Returns a value indicating what this QXmlQuery is being used for. The default is QXmlQuery::XQuery10, which means the QXmlQuery is being used for running XQuery and XPath queries. QXmlQuery::XSLT20 can also be returned, which indicates the QXmlQuery is for running XSL-T spreadsheets.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.BindVariable(QtXmlPatterns.QXmlName,QtXmlPatterns.QXmlItem)">
            <summary>
                <para>Binds the variable name to the value so that $name can be used from within the query to refer to the value.</para>
                <para>name must not be null. name.isNull() must return false. If name has already been bound by a previous bindVariable() call, its previous binding will be overridden.</para>
                <para>If value is null so that value.isNull() returns true, and name already has a binding, the effect is to remove the existing binding for name.</para>
                <para>To bind a value of type QString or QUrl, wrap the value in a QVariant such that QXmlItem's QVariant constructor is called.</para>
                <para>All strings processed by the query must be valid XQuery strings, which means they must contain only XML 1.0 characters. However, this requirement is not checked. If the query processes an invalid string, the behavior is undefined.</para>
                <para>See also QVariant::isValid(), How QVariant maps to XQuery's Data Model, and QXmlItem::isNull().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.BindVariable(QtXmlPatterns.QXmlName,QtCore.QIODevice)">
            <summary>
                <para>Binds the variable name to the device so that $name can be used from within the query to refer to the device. The QIODevice device is exposed to the query as a URI of type xs:anyURI, which can be passed to the fn:doc() function to be read. E.g., this function can be used to pass an XML document in memory to fn:doc.</para>
                <para>     QByteArray myDocument;</para>
                <para>     QBuffer buffer(&amp;myDocument); // This is a QIODevice.</para>
                <para>     buffer.open(QIODevice::ReadOnly);</para>
                <para>     QXmlQuery query;</para>
                <para>     query.bindVariable("myDocument", &amp;buffer);</para>
                <para>     query.setQuery("doc($myDocument)");</para>
                <para>The caller must ensure that device has been opened with at least QIODevice::ReadOnly prior to this binding. Otherwise, behavior is undefined.</para>
                <para>If the query will access an XML document contained in a QString, use a QBuffer as shown in the following snippet. Suppose myQString contains &lt;document&gt;content&lt;/document&gt;</para>
                <para>     QBuffer device;</para>
                <para>     device.setData(myQString.toUtf8());</para>
                <para>     device.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>     QXmlQuery query;</para>
                <para>     query.bindVariable("inputDocument", &amp;device);</para>
                <para>     query.setQuery("doc($inputDocument)/query[theDocument]");</para>
                <para>name must not be null. name.isNull() must return false. If name has already been bound, its previous binding will be overridden. The URI that name evaluates to is arbitrary and may change.</para>
                <para>If the type of the variable binding changes (e.g., if a previous binding by the same name was a QVariant, or if there was no previous binding), isValid() will return false, and recompilation of the query text is required. To recompile the query, call setQuery(). For this reason, bindVariable() should be called before setQuery(), if possible.</para>
                <para>Note: device must not be deleted while this QXmlQuery exists.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.BindVariable(QtXmlPatterns.QXmlName,QtXmlPatterns.QXmlQuery)">
            <summary>
                <para>Binds the result of the query query, to a variable by name name.</para>
                <para>Evaluation of query will be commenced when this function is called.</para>
                <para>If query is invalid, behavior is undefined. query will be copied.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.BindVariable(System.String,QtXmlPatterns.QXmlItem)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>This function constructs a QXmlName from localName using the query's namespace. The function then behaves as the overloaded function. It is equivalent to the following snippet.</para>
                <para>     QXmlNamePool namePool(query.namePool());</para>
                <para>     query.bindVariable(QXmlName(namePool, localName), value);</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.BindVariable(System.String,QtCore.QIODevice)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>If localName is a valid NCName, this function is equivalent to the following snippet.</para>
                <para>     QXmlNamePool namePool(query.namePool());</para>
                <para>     query.bindVariable(QXmlName(namePool, localName), device);</para>
                <para>A QXmlName is constructed from localName, and is passed to the appropriate overload along with device.</para>
                <para>See also QXmlName::isNCName().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.BindVariable(System.String,QtXmlPatterns.QXmlQuery)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Has the same behavior and effects as the function being overloaded, but takes the variable name localName as a QString. query is used as in the overloaded function.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.EvaluateTo(QtXmlPatterns.QXmlResultItems)">
            <summary>
                <para>Starts the evaluation and makes it available in result. If result is null, the behavior is undefined. The evaluation takes place incrementally (lazy evaluation), as the caller uses QXmlResultItems::next() to get the next result.</para>
                <para>See also QXmlResultItems::next().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.EvaluateTo(QtXmlPatterns.QAbstractXmlReceiver)">
            <summary>
                <para>Evaluates this query and sends the result as a sequence of callbacks to the receiver callback. QXmlQuery does not take ownership of callback.</para>
                <para>If an error occurs during the evaluation, error messages are sent to messageHandler() and false is returned.</para>
                <para>If this query is invalid, false is returned and the behavior is undefined. If callback is null, behavior is undefined.</para>
                <para>See also QAbstractXmlReceiver and isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.EvaluateTo(QtCore.QIODevice)">
            <summary>
                <para>Evaluates the query or stylesheet, and writes the output to target.</para>
                <para>QXmlSerializer is used to write the output to target. In a future release, it is expected that this function will be changed to respect serialization options set in the stylesheet.</para>
                <para>If an error occurs during the evaluation, error messages are sent to messageHandler() and false is returned.</para>
                <para>If target is null, or is not opened in at least QIODevice::WriteOnly mode, the behavior is undefined. QXmlQuery does not take ownership of target.</para>
                <para>This is an overloaded function.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.EvaluateTo(System.Text.StringBuilder)">
            <summary>
                <para>Evaluates the query, and serializes the output as XML to output.</para>
                <para>If an error occurs during the evaluation, error messages are sent to messageHandler(), the content of output is undefined and false is returned, otherwise true is returned.</para>
                <para>If output is null behavior is undefined. QXmlQuery does not take ownership of output.</para>
                <para>Internally, the class QXmlFormatter is used for this.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.EvaluateTo(System.Collections.Generic.List{System.String})">
            <summary>
                <para>Attempts to evaluate the query and returns the results in the target string list.</para>
                <para>If the query is valid and the evaluation succeeds, true is returned. Otherwise, false is returned and the contents of target are undefined.</para>
                <para>The query must evaluate to a sequence of xs:string values. If the query does not evaluate to a sequence of strings, the values can often be converted by adding a call to string() at the end of the XQuery.</para>
                <para>If target is null, the behavior is undefined.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetFocus(QtXmlPatterns.QXmlItem)">
            <summary>
                <para>Sets the focus to item. The focus is the set of items that the context item expression and path expressions navigate from. For example, in the expression p/span, the element that p evaluates to is the focus for the following expression, span.</para>
                <para>The focus can be accessed using the context item expression, i.e., dot (".").</para>
                <para>By default, the focus is not set and is undefined. It will therefore result in a dynamic error, XPDY0002, if the focus is attempted to be accessed. The focus must be set before the query is set with setQuery().</para>
                <para>There is no behavior defined for setting an item which is null.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetFocus(QtCore.QUrl)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the focus to be the document located at documentURI and returns true. If documentURI cannot be loaded, false is returned. It is undefined at what time the document may be loaded. When loading the document, the message handler and URI resolver set on this QXmlQuery are used.</para>
                <para>If documentURI is empty or is not a valid URI, the behavior of this function is undefined.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetFocus(QtCore.QIODevice)">
            <summary>
                <para>Sets the focus to be the document read from the QIODevice and returns true. If document cannot be loaded, false is returned.</para>
                <para>QXmlQuery does not take ownership of document. The user guarantees that a document is available from the document device and that the document is not empty. The device must be opened in at least read-only mode. document must stay in scope as long as the current query is active.</para>
                <para>This is an overloaded function.</para>
                <para>This function was introduced in Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetFocus(System.String)">
            <summary>
                <para>This function behaves identically to calling the setFocus() overload with a QIODevice whose content is focus encoded as UTF-8. That is, focus is treated as if it contained an XML document.</para>
                <para>Returns the same result as the overload.</para>
                <para>This is an overloaded function.</para>
                <para>This function was introduced in Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetInitialTemplateName(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>Sets the name of the initial template to localName, which must be a valid local name. The initial template is the one the processor calls first, instead of attempting to match a template to the context node (if any). If an initial template is not set, the standard order of template invocation will be used.</para>
                <para>This function only applies when using QXmlQuery to process XSL-T stylesheets. The name becomes part of the compiled stylesheet. Therefore, this function must be called before calling setQuery().</para>
                <para>If localName is not a valid local name, the effect is undefined. If the stylesheet has no template named localName, the processor will use the standard order of template invocation.</para>
                <para>This function was introduced in Qt 4.5.</para>
                <para>See also initialTemplateName().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetQuery(QtCore.QIODevice)">
            <summary>
                <para>Sets this QXmlQuery to an XQuery read from the sourceCode device. The device must have been opened with at least QIODevice::ReadOnly.</para>
                <para>documentURI represents the query obtained from the sourceCode device. It is the base URI of the static context, as defined in the XQuery language. It is used internally to resolve relative URIs that appear in the query, and for message reporting. documentURI can be empty. If it is empty, the application file path is used. If it is not empty, it may be either relative or absolute. If it is relative, it is resolved itself against the application file path before it is used. If documentURI is neither a valid URI nor empty, the result is undefined.</para>
                <para>If the query contains a static error (e.g. syntax error), an error message is sent to the messageHandler(), and isValid() will return false.</para>
                <para>Variables must be bound before setQuery() is called.</para>
                <para>The encoding of the XQuery in sourceCode is detected internally using the rules for setting and detecting encoding of XQuery files, which are explained in the XQuery language.</para>
                <para>If sourceCode is null or not readable, or if documentURI is not a valid URI, behavior is undefined.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetQuery(QtCore.QUrl)">
            <summary>
                <para>Sets this QXmlQuery to the XQuery read from the queryURI. Use isValid() after calling this function. If an error occurred reading queryURI, e.g., the query does not exist, cannot be read, or is invalid, isValid() will return false.</para>
                <para>The supported URI schemes are the same as those in the XQuery function fn:doc, except that queryURI can be the object of a variable binding.</para>
                <para>baseURI is the Base URI of the static context, as defined in the XQuery language. It is used internally to resolve relative URIs that appear in the query, and for message reporting. If baseURI is empty, queryURI is used. Otherwise, baseURI is used, and it is resolved against the application file path if it is relative.</para>
                <para>If queryURI is empty or invalid, or if baseURI is invalid, the behavior of this function is undefined.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetQuery(QtCore.QIODevice,QtCore.QUrl)">
            <summary>
                <para>Sets this QXmlQuery to an XQuery read from the sourceCode device. The device must have been opened with at least QIODevice::ReadOnly.</para>
                <para>documentURI represents the query obtained from the sourceCode device. It is the base URI of the static context, as defined in the XQuery language. It is used internally to resolve relative URIs that appear in the query, and for message reporting. documentURI can be empty. If it is empty, the application file path is used. If it is not empty, it may be either relative or absolute. If it is relative, it is resolved itself against the application file path before it is used. If documentURI is neither a valid URI nor empty, the result is undefined.</para>
                <para>If the query contains a static error (e.g. syntax error), an error message is sent to the messageHandler(), and isValid() will return false.</para>
                <para>Variables must be bound before setQuery() is called.</para>
                <para>The encoding of the XQuery in sourceCode is detected internally using the rules for setting and detecting encoding of XQuery files, which are explained in the XQuery language.</para>
                <para>If sourceCode is null or not readable, or if documentURI is not a valid URI, behavior is undefined.</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetQuery(QtCore.QUrl,QtCore.QUrl)">
            <summary>
                <para>Sets this QXmlQuery to the XQuery read from the queryURI. Use isValid() after calling this function. If an error occurred reading queryURI, e.g., the query does not exist, cannot be read, or is invalid, isValid() will return false.</para>
                <para>The supported URI schemes are the same as those in the XQuery function fn:doc, except that queryURI can be the object of a variable binding.</para>
                <para>baseURI is the Base URI of the static context, as defined in the XQuery language. It is used internally to resolve relative URIs that appear in the query, and for message reporting. If baseURI is empty, queryURI is used. Otherwise, baseURI is used, and it is resolved against the application file path if it is relative.</para>
                <para>If queryURI is empty or invalid, or if baseURI is invalid, the behavior of this function is undefined.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetQuery(System.String)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>The behavior and requirements of this function are the same as for setQuery(QIODevice*, const QUrl&amp;), after the XQuery has been read from the IO device into a string. Because sourceCode is already a Unicode string, detection of its encoding is unnecessary.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.SetQuery(System.String,QtCore.QUrl)">
            <summary>
                <para>This is an overloaded function.</para>
                <para>The behavior and requirements of this function are the same as for setQuery(QIODevice*, const QUrl&amp;), after the XQuery has been read from the IO device into a string. Because sourceCode is already a Unicode string, detection of its encoding is unnecessary.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlQuery.Finalize">
            <summary>
                <para>Destroys this QXmlQuery.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlResultItems">
            <summary>
            The QXmlResultItems class iterates through the results of evaluating an XQuery in QXmlQuery.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QXmlResultItems presents the evaluation of an associated query as a sequence of QXmlItems. The sequence is traversed by repeatedly calling next(), which actually produces the sequence by lazy evaluation of the query.</para>
                <para> QXmlQuery query;</para>
                <para> query.setQuery("&lt;e/&gt;, 1, 'two'");</para>
                <para> QXmlResultItems result;</para>
                <para>
                </para>
                <para> if (query.isValid()) {</para>
                <para>     query.evaluateTo(&amp;result);</para>
                <para>     QXmlItem item(result.next());</para>
                <para>     while (!item.isNull()) {</para>
                <para>         // use item</para>
                <para>         item = result.next();</para>
                <para>     }</para>
                <para>     if (result.hasError())</para>
                <para>         /* Runtime error! */;</para>
                <para> }</para>
                <para>An effect of letting next() produce the sequence by lazy evaluation is that a query error can occur on any call to next(). If an error occurs, both next() and current() will return the null QXmlItem, and hasError() will return true.</para>
                <para>QXmlResultItems can be thought of as an "iterator" that traverses the sequence of query results once, in the forward direction. Each call to next() advances the iterator to the next QXmlItem in the sequence and returns it, and current() always returns the QXmlItem that next() returned the last time it was called.</para>
                <para>Note: When using the QXmlResultItems overload of QXmlQuery::evaluateTo() to execute a query, it is advisable to create a new instance of this class for each new set of results rather than reusing an old instance.</para>
                <para>
                </para>
                <para>See also QXmlItem::isNode(), QXmlItem::isAtomicValue(), and QXmlNodeModelIndex.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlResultItems.#ctor">
            <summary>
                <para>Constructs an instance of QXmlResultItems.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlResultItems.Current">
            <summary>
                <para>Returns the current item. The current item is the last item that was produced and returned by next().</para>
                <para>Returns a null QXmlItem if there is no associated QXmlQuery.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlResultItems.HasError">
            <summary>
                <para>If an error occurred during evaluation of the query, true is returned.</para>
                <para>Returns false if query evaluation has been done.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlResultItems.Next">
            <summary>
                <para>Returns the next result in the sequence produced by lazy evaluation of the associated query. When the returned QXmlItem is null, either the evaluation terminated normally without producing another result, or an error occurred. Call hasError() to determine whether the null item was caused by normal termination or by an error.</para>
                <para>Returns a null QXmlItem if there is no associated QXmlQuery.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlResultItems.Finalize">
            <summary>
                <para>Destroys this instance of QXmlResultItems.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlSchema">
            <summary>
            The QXmlSchema class provides loading and validation of a W3C XML Schema.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QXmlSchema class loads, compiles and validates W3C XML Schema files that can be used further for validation of XML instance documents via QXmlSchemaValidator.</para>
                <para>The following example shows how to load a XML Schema file from the network and test whether it is a valid schema document:</para>
                <para>     QUrl url("http://www.schema-example.org/myschema.xsd");</para>
                <para>
                </para>
                <para>     QXmlSchema schema;</para>
                <para>     if (schema.load(url) == true)</para>
                <para>         qDebug() &lt;&lt; "schema is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "schema is invalid";</para>
                <para>
                </para>
                <para>XML Schema Version</para>
                <para>This class is used to represent schemas that conform to the XML Schema 1.0 specification.</para>
                <para>
                </para>
                <para>See also QXmlSchemaValidator and XML Schema Validation Example.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.#ctor">
            <summary>
                <para>Constructs an invalid, empty schema that cannot be used until load() is called.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.#ctor(QtXmlPatterns.QXmlSchema)">
            <summary>
                <para>Constructs a QXmlSchema that is a copy of other. The new instance will share resources with the existing schema to the extent possible.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchema.MessageHandler">
            <summary>
                <para>Returns the message handler that handles compile and validation messages for this QXmlSchema.</para>
                <para>Changes the message handler for this QXmlSchema to handler. The schema sends all compile and validation messages to this message handler. QXmlSchema does not take ownership of handler.</para>
                <para>Normally, the default message handler is sufficient. It writes compile and validation messages to stderr. The default message handler includes color codes if stderr can render colors.</para>
                <para>When QXmlSchema calls QAbstractMessageHandler::message(), the arguments are as follows:</para>
                <para>
                </para>
                <para>message() argumentSemantics</para>
                <para>QtMsgType type	Only QtWarningMsg and QtFatalMsg are used. The former identifies a warning, while the latter identifies an error.</para>
                <para>const QString &amp; description	An XHTML document which is the actual message. It is translated into the current language.</para>
                <para>const QUrl &amp;identifier	Identifies the error with a URI, where the fragment is the error code, and the rest of the URI is the error namespace.</para>
                <para>const QSourceLocation &amp; sourceLocation	Identifies where the error occurred.</para>
                <para>
                </para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchema.NetworkAccessManager">
            <summary>
                <para>Returns the network manager, or 0 if it has not been set.</para>
                <para>Sets the network manager to manager. QXmlSchema does not take ownership of manager.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchema.UriResolver">
            <summary>
                <para>Returns the schema's URI resolver. If no URI resolver has been set, QtXmlPatterns will use the URIs in schemas as they are.</para>
                <para>The URI resolver provides a level of abstraction, or polymorphic URIs. A resolver can rewrite logical URIs to physical ones, or it can translate obsolete or invalid URIs to valid ones.</para>
                <para>When QtXmlPatterns calls QAbstractUriResolver::resolve() the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.</para>
                <para>Sets the URI resolver to resolver. QXmlSchema does not take ownership of resolver.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchema.DocumentUri">
            <summary>
                <para>Returns the document URI of the schema or an empty URI if no schema has been set.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchema.IsValid">
            <summary>
                <para>Returns true if this schema is valid. Examples of invalid schemas are ones that contain syntax errors or that do not conform the W3C XML Schema specification.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchema.NamePool">
            <summary>
                <para>Returns the name pool used by this QXmlSchema for constructing names. There is no setter for the name pool, because mixing name pools causes errors due to name confusion.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.Load(QtCore.QUrl)">
            <summary>
                <para>Sets this QXmlSchema to a schema loaded from the source URI.</para>
                <para>If the schema is invalid, false is returned and the behavior is undefined.</para>
                <para>Example:</para>
                <para>     QUrl url("http://www.schema-example.org/myschema.xsd");</para>
                <para>
                </para>
                <para>     QXmlSchema schema;</para>
                <para>     if (schema.load(url) == true)</para>
                <para>         qDebug() &lt;&lt; "schema is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "schema is invalid";</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.Load(QtCore.QIODevice)">
            <summary>
                <para>Sets this QXmlSchema to a schema read from the source device. The device must have been opened with at least QIODevice::ReadOnly.</para>
                <para>documentUri represents the schema obtained from the source device. It is the base URI of the schema, that is used internally to resolve relative URIs that appear in the schema, and for message reporting.</para>
                <para>If source is null or not readable, or if documentUri is not a valid URI, behavior is undefined.</para>
                <para>If the schema is invalid, false is returned and the behavior is undefined.</para>
                <para>Example:</para>
                <para>     QFile file("myschema.xsd");</para>
                <para>     file.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>     QXmlSchema schema;</para>
                <para>     schema.load(&amp;file, QUrl::fromLocalFile(file.fileName()));</para>
                <para>
                </para>
                <para>     if (schema.isValid())</para>
                <para>         qDebug() &lt;&lt; "schema is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "schema is invalid";</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.Load(QtCore.QByteArray)">
            <summary>
                <para>Sets this QXmlSchema to a schema read from the data</para>
                <para>documentUri represents the schema obtained from the data. It is the base URI of the schema, that is used internally to resolve relative URIs that appear in the schema, and for message reporting.</para>
                <para>If documentUri is not a valid URI, behavior is undefined.</para>
                <para>If the schema is invalid, false is returned and the behavior is undefined.</para>
                <para>Example:</para>
                <para>     QByteArray data( "&lt;?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?&gt;"</para>
                <para>                      "&lt;xsd:schema"</para>
                <para>                      "        xmlns:xsd=\\"http://www.w3.org/2001/XMLSchema\\""</para>
                <para>                      "        xmlns=\\"http://qt.nokia.com/xmlschematest\\""</para>
                <para>                      "        targetNamespace=\\"http://qt.nokia.com/xmlschematest\\""</para>
                <para>                      "        version=\\"1.0\\""</para>
                <para>                      "        elementFormDefault=\\"qualified\\"&gt;"</para>
                <para>                      "&lt;/xsd:schema&gt;" );</para>
                <para>
                </para>
                <para>     QXmlSchema schema;</para>
                <para>     schema.load(data);</para>
                <para>
                </para>
                <para>     if (schema.isValid())</para>
                <para>         qDebug() &lt;&lt; "schema is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "schema is invalid";</para>
                <para>See also isValid() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.Load(QtCore.QIODevice,QtCore.QUrl)">
            <summary>
                <para>Sets this QXmlSchema to a schema read from the source device. The device must have been opened with at least QIODevice::ReadOnly.</para>
                <para>documentUri represents the schema obtained from the source device. It is the base URI of the schema, that is used internally to resolve relative URIs that appear in the schema, and for message reporting.</para>
                <para>If source is null or not readable, or if documentUri is not a valid URI, behavior is undefined.</para>
                <para>If the schema is invalid, false is returned and the behavior is undefined.</para>
                <para>Example:</para>
                <para>     QFile file("myschema.xsd");</para>
                <para>     file.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>     QXmlSchema schema;</para>
                <para>     schema.load(&amp;file, QUrl::fromLocalFile(file.fileName()));</para>
                <para>
                </para>
                <para>     if (schema.isValid())</para>
                <para>         qDebug() &lt;&lt; "schema is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "schema is invalid";</para>
                <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.Load(QtCore.QByteArray,QtCore.QUrl)">
            <summary>
                <para>Sets this QXmlSchema to a schema read from the data</para>
                <para>documentUri represents the schema obtained from the data. It is the base URI of the schema, that is used internally to resolve relative URIs that appear in the schema, and for message reporting.</para>
                <para>If documentUri is not a valid URI, behavior is undefined.</para>
                <para>If the schema is invalid, false is returned and the behavior is undefined.</para>
                <para>Example:</para>
                <para>     QByteArray data( "&lt;?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?&gt;"</para>
                <para>                      "&lt;xsd:schema"</para>
                <para>                      "        xmlns:xsd=\\"http://www.w3.org/2001/XMLSchema\\""</para>
                <para>                      "        xmlns=\\"http://qt.nokia.com/xmlschematest\\""</para>
                <para>                      "        targetNamespace=\\"http://qt.nokia.com/xmlschematest\\""</para>
                <para>                      "        version=\\"1.0\\""</para>
                <para>                      "        elementFormDefault=\\"qualified\\"&gt;"</para>
                <para>                      "&lt;/xsd:schema&gt;" );</para>
                <para>
                </para>
                <para>     QXmlSchema schema;</para>
                <para>     schema.load(data);</para>
                <para>
                </para>
                <para>     if (schema.isValid())</para>
                <para>         qDebug() &lt;&lt; "schema is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "schema is invalid";</para>
                <para>See also isValid() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchema.Finalize">
            <summary>
                <para>Destroys this QXmlSchema.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlSchemaValidator">
            <summary>
            The QXmlSchemaValidator class validates XML instance documents against a W3C XML Schema.
            </summary>
            <remarks>
                <para>
                </para>
                <para>The QXmlSchemaValidator class loads, parses an XML instance document and validates it against a W3C XML Schema that has been compiled with QXmlSchema.</para>
                <para>The following example shows how to load a XML Schema from a local file, check whether it is a valid schema document and use it for validation of an XML instance document:</para>
                <para>     QUrl schemaUrl("file:///home/user/schema.xsd");</para>
                <para>
                </para>
                <para>     QXmlSchema schema;</para>
                <para>     schema.load(schemaUrl);</para>
                <para>
                </para>
                <para>     if (schema.isValid()) {</para>
                <para>         QFile file("test.xml");</para>
                <para>         file.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>         QXmlSchemaValidator validator(schema);</para>
                <para>         if (validator.validate(&amp;file, QUrl::fromLocalFile(file.fileName())))</para>
                <para>             qDebug() &lt;&lt; "instance document is valid";</para>
                <para>         else</para>
                <para>             qDebug() &lt;&lt; "instance document is invalid";</para>
                <para>     }</para>
                <para>
                </para>
                <para>XML Schema Version</para>
                <para>This class implements schema validation according to the XML Schema 1.0 specification.</para>
                <para>
                </para>
                <para>See also QXmlSchema and XML Schema Validation Example.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.#ctor">
            <summary>
                <para>Constructs a schema validator. The schema used for validation must be referenced in the XML instance document via the xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.#ctor(QtXmlPatterns.QXmlSchema)">
            <summary>
                <para>Constructs a schema validator that will use schema for validation. If an empty QXmlSchema schema is passed to the validator, the schema used for validation must be referenced in the XML instance document via the xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchemaValidator.MessageHandler">
            <summary>
                <para>Returns the message handler that handles parsing and validation messages for this QXmlSchemaValidator.</para>
                <para>Changes the message handler for this QXmlSchemaValidator to handler. The schema validator sends all parsing and validation messages to this message handler. QXmlSchemaValidator does not take ownership of handler.</para>
                <para>Normally, the default message handler is sufficient. It writes compile and validation messages to stderr. The default message handler includes color codes if stderr can render colors.</para>
                <para>When QXmlSchemaValidator calls QAbstractMessageHandler::message(), the arguments are as follows:</para>
                <para>
                </para>
                <para>message() argumentSemantics</para>
                <para>QtMsgType type	Only QtWarningMsg and QtFatalMsg are used. The former identifies a warning, while the latter identifies an error.</para>
                <para>const QString &amp; description	An XHTML document which is the actual message. It is translated into the current language.</para>
                <para>const QUrl &amp;identifier	Identifies the error with a URI, where the fragment is the error code, and the rest of the URI is the error namespace.</para>
                <para>const QSourceLocation &amp; sourceLocation	Identifies where the error occurred.</para>
                <para>
                </para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchemaValidator.NetworkAccessManager">
            <summary>
                <para>Returns the network manager, or 0 if it has not been set.</para>
                <para>Sets the network manager to manager. QXmlSchemaValidator does not take ownership of manager.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchemaValidator.Schema">
            <summary>
                <para>Returns the schema that is used for validation.</para>
                <para>Sets the schema that shall be used for further validation. If the schema is empty, the schema used for validation must be referenced in the XML instance document via the xsi:schemaLocation or xsi:noNamespaceSchemaLocation attribute.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchemaValidator.UriResolver">
            <summary>
                <para>Returns the schema's URI resolver. If no URI resolver has been set, QtXmlPatterns will use the URIs in instance documents as they are.</para>
                <para>The URI resolver provides a level of abstraction, or polymorphic URIs. A resolver can rewrite logical URIs to physical ones, or it can translate obsolete or invalid URIs to valid ones.</para>
                <para>When QtXmlPatterns calls QAbstractUriResolver::resolve() the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.</para>
                <para>Sets the URI resolver to resolver. QXmlSchemaValidator does not take ownership of resolver.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSchemaValidator.NamePool">
            <summary>
                <para>Returns the name pool used by this QXmlSchemaValidator for constructing names. There is no setter for the name pool, because mixing name pools causes errors due to name confusion.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.Validate(QtCore.QUrl)">
            <summary>
                <para>Validates the XML instance document read from source against the schema.</para>
                <para>Returns true if the XML instance document is valid according to the schema, false otherwise.</para>
                <para>Example:</para>
                <para>     const QXmlSchema schema = getSchema();</para>
                <para>
                </para>
                <para>     const QUrl url("http://www.schema-example.org/test.xml");</para>
                <para>
                </para>
                <para>     QXmlSchemaValidator validator(schema);</para>
                <para>     if (validator.validate(url))</para>
                <para>         qDebug() &lt;&lt; "instance document is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "instance document is invalid";</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.Validate(QtCore.QIODevice)">
            <summary>
                <para>Validates the XML instance document read from source with the given documentUri against the schema.</para>
                <para>Returns true if the XML instance document is valid according to the schema, false otherwise.</para>
                <para>Example:</para>
                <para>     const QXmlSchema schema = getSchema();</para>
                <para>
                </para>
                <para>     QFile file("test.xml");</para>
                <para>     file.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>     QXmlSchemaValidator validator(schema);</para>
                <para>     if (validator.validate(&amp;file, QUrl::fromLocalFile(file.fileName())))</para>
                <para>         qDebug() &lt;&lt; "instance document is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "instance document is invalid";</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.Validate(QtCore.QByteArray)">
            <summary>
                <para>Validates the XML instance document read from data with the given documentUri against the schema.</para>
                <para>Returns true if the XML instance document is valid according to the schema, false otherwise.</para>
                <para>Example:</para>
                <para>     const QXmlSchema schema = getSchema();</para>
                <para>
                </para>
                <para>     QByteArray data("&lt;?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?&gt;"</para>
                <para>                     "&lt;test&gt;&lt;/test&gt;");</para>
                <para>
                </para>
                <para>     QBuffer buffer(&amp;data);</para>
                <para>     buffer.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>     QXmlSchemaValidator validator(schema);</para>
                <para>     if (validator.validate(&amp;buffer))</para>
                <para>         qDebug() &lt;&lt; "instance document is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "instance document is invalid";</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.Validate(QtCore.QIODevice,QtCore.QUrl)">
            <summary>
                <para>Validates the XML instance document read from source with the given documentUri against the schema.</para>
                <para>Returns true if the XML instance document is valid according to the schema, false otherwise.</para>
                <para>Example:</para>
                <para>     const QXmlSchema schema = getSchema();</para>
                <para>
                </para>
                <para>     QFile file("test.xml");</para>
                <para>     file.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>     QXmlSchemaValidator validator(schema);</para>
                <para>     if (validator.validate(&amp;file, QUrl::fromLocalFile(file.fileName())))</para>
                <para>         qDebug() &lt;&lt; "instance document is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "instance document is invalid";</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.Validate(QtCore.QByteArray,QtCore.QUrl)">
            <summary>
                <para>Validates the XML instance document read from data with the given documentUri against the schema.</para>
                <para>Returns true if the XML instance document is valid according to the schema, false otherwise.</para>
                <para>Example:</para>
                <para>     const QXmlSchema schema = getSchema();</para>
                <para>
                </para>
                <para>     QByteArray data("&lt;?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?&gt;"</para>
                <para>                     "&lt;test&gt;&lt;/test&gt;");</para>
                <para>
                </para>
                <para>     QBuffer buffer(&amp;data);</para>
                <para>     buffer.open(QIODevice::ReadOnly);</para>
                <para>
                </para>
                <para>     QXmlSchemaValidator validator(schema);</para>
                <para>     if (validator.validate(&amp;buffer))</para>
                <para>         qDebug() &lt;&lt; "instance document is valid";</para>
                <para>     else</para>
                <para>         qDebug() &lt;&lt; "instance document is invalid";</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSchemaValidator.Finalize">
            <summary>
                <para>Destroys this QXmlSchemaValidator.</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QXmlSerializer">
            <summary>
            The QXmlSerializer class is an implementation of QAbstractXmlReceiver for transforming XQuery output into unformatted XML.
            </summary>
            <remarks>
                <para>
                </para>
                <para>QXmlSerializer translates an XQuery sequence, usually the output of an QXmlQuery, into XML. Consider the example:</para>
                <para> QXmlQuery query;</para>
                <para> query.setQuery("doc('index.html')/html/body/p[1]");</para>
                <para>
                </para>
                <para> QXmlSerializer serializer(query, myOutputDevice);</para>
                <para> query.evaluateTo(&amp;serializer);</para>
                <para>First it constructs a query that gets the first paragraph from document index.html. Then it constructs an instance of this class with the query and myOutputDevice. Finally, it evaluates the query, producing an ordered sequence of calls to the serializer's callback functions. The sequence of callbacks transforms the query output to XML and writes it to myOutputDevice.</para>
                <para>QXmlSerializer will:</para>
                <para>
                </para>
                <para>Declare namespaces when needed,</para>
                <para>Use appropriate escaping, when characters can't be represented in the XML,</para>
                <para>Handle line endings appropriately,</para>
                <para>Report errors, when it can't serialize the content, e.g., when asked to serialize an attribute that is a top-level node, or when more than one top-level element is encountered.</para>
                <para>
                </para>
                <para>If an error occurs during serialization, result is undefined unless the serializer is driven through a call to QXmlQuery::evaluateTo().</para>
                <para>If the generated XML should be indented and formatted for reading, use QXmlFormatter.</para>
                <para>
                </para>
                <para>See also XSLT 2.0 and XQuery 1.0 Serialization and QXmlFormatter.</para>
            </remarks>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.#ctor(QtXmlPatterns.QXmlQuery,QtCore.QIODevice)">
            <summary>
                <para>Constructs a serializer that uses the name pool and message handler in query, and writes the output to outputDevice.</para>
                <para>outputDevice must be a valid, non-null device that is open in write mode, otherwise behavior is undefined.</para>
                <para>outputDevice must not be opened with QIODevice::Text because it will cause the output to be incorrect. This class will ensure line endings are serialized as according with the XML specification. QXmlSerializer does not take ownership of outputDevice.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSerializer.Codec">
            <summary>
                <para>Returns the codec being used by the serializer for encoding its XML output.</para>
                <para>Sets the codec the serializer will use for encoding its XML output. The output codec is set to outputCodec. By default, the output codec is set to the one for UTF-8. The serializer does not take ownership of the codec.</para>
            </summary>
        </member>
        <member name="P:QtXmlPatterns.QXmlSerializer.OutputDevice">
            <summary>
                <para>Returns a pointer to the output device. There is no corresponding function to set the output device, because the output device must be passed to the constructor. The serializer does not take ownership of its IO device.</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.AtomicValue(System.Object)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::atomicValue().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.Attribute(QtXmlPatterns.QXmlName,QtCore.QStringRef)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::attribute().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.Characters(QtCore.QStringRef)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::characters().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.Comment(System.String)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::comment().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.EndDocument">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::endDocument().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.EndElement">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::endElement().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.EndOfSequence">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::endOfSequence().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.NamespaceBinding(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::namespaceBinding().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.ProcessingInstruction(QtXmlPatterns.QXmlName,System.String)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::processingInstruction().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.StartDocument">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::startDocument().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.StartElement(QtXmlPatterns.QXmlName)">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::startElement().</para>
            </summary>
        </member>
        <member name="M:QtXmlPatterns.QXmlSerializer.StartOfSequence">
            <summary>
                <para>Reimplemented from QAbstractXmlReceiver::startOfSequence().</para>
            </summary>
        </member>
        <member name="T:QtXmlPatterns.QtMsgType">
            <summary>
                <para>This enum describes the messages that can be sent to a message handler (QtMsgHandler). You can use the enum to identify and associate the various message types with the appropriate actions.</para>
                <para>See also QtMsgHandler and qInstallMsgHandler().</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QtMsgType.QtCriticalMsg">
            <summary>
                <para>A message generated by the qCritical() function.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QtMsgType.QtDebugMsg">
            <summary>
                <para>A message generated by the qDebug() function.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QtMsgType.QtFatalMsg">
            <summary>
                <para>A message generated by the qFatal() function.</para>
            </summary>
        </member>
        <member name="F:QtXmlPatterns.QtMsgType.QtWarningMsg">
            <summary>
                <para>A message generated by the qWarning() function.</para>
            </summary>
        </member>
    </members>
</doc>
